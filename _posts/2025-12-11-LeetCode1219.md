---
layout: post
title: "力扣第1219题黄金矿工时间复杂度新解"
author: sam
categories: [ 算法 ]
image: assets/images/leetcode1219/cover.jpg
math: true
featured: false
hidden: false
---

## 算法思路

用二维向量存储金矿的分布情况。算法首先遍历整个金矿，对于不为0的坐标将其设为起点，用DFS回溯搜索整张图，搜索过程中将已走过的坐标标记（金子数置0），同时记录当前收集到的金子数量。

类中有一个 `max` 变量记录最多收集到的金子数量，一个 `path` 变量记录最优情况的路径。当找到收集金子更多的路径时，会同时更新 `max` 与 `path`。回溯时，记录当前路径的栈 pop 一次，并释放标记。由此，即可找出收集黄金最多的路径与金子数。

## 复杂度分析

鉴于搜索的结果取决于对有金子区域的遍历，因此设有金子区域一共有 $$k$$ 个。再设行数为 $$m$$，列数为 $$n$$。显然，$$k \le mn$$，因此后续涉及 $$\min\{mn, k\}$$ 运算时可以直接化简为 $$k$$。

在算法中使用了两个栈存储路径，因此空间复杂度为 $$O(k+k)$$，即 $$O(k)$$。

将每次向前探索作为基本操作。每个有金子的地点都可以作为起点开始DFS遍历，因此一共有 $$k$$ 次遍历。在每次遍历中，除第一个地点外，每个地点都有最多三个不同的方向继续前进遍历，因此探索操作至少有 $3k$ 次。可知时间复杂度最差为 $$O(3^k)$$。

但是自己输入一个 $$k=25$$ 的地图数据发现执行效率相当高，并没有体现出以3为底指数函数的低效率，推断“每个起点的总探索操作上限 $$3^k$$ 次”这个数据将上限抬得过高。

因为探索操作都产生在有金子的格子里，所以将其单独拿出分析，对于任何一条收集路线，除开首尾两格，中间的格子被路线穿过都不外乎如下七种情况：

1.  左进上出或上进左出——简写为 **LU**
2.  右进上出或上进右出——简写为 **RU**
3.  还有 **LD**、**RD**、**LR**、**UD**
4.  没有被路线穿过的情况，记为 **N**

这样原先由每个格子三种探索方向构成的解空间树就变成了对每个格子其中穿过情况生成解空间树。

再将整张图中所有有金子的格子（除首尾）如下交错划分成黑白两种：（此处为方便说明假设它们恰好聚在这 $$3 \times 3$$ 格子里）

![Figure1]({{site.baseurl}}/assets/images/leetcode1219/fig1.png){: .mx-auto .d-block}

从刚才的 7 种情况可以知道，如果我们确定每个黑色格子的情况，白色格子的情况就被确定了，所以我们只需要考虑黑色格子，显然这样的划分形成了 $$k/2$$ 数量级的黑格子。

解空间树生成时，遍历 B 的 7 种情况前它周围四个角的黑格情况已经被确定了（除开首尾，这对时间复杂度分析没有影响），图中假设 A 被确定为 LR，那么 B 只剩 LU、RU、UD、N 四种情况。其它同理，因此实际上生成解空间树时每个黑格子下一步能够做出的探索选择只有 4 种，时间复杂度最差不超过 $$O(4^{k/2}) = O(2^k)$$。

实际情况下因为有金子的格子不会总是聚在一起，因此每个黑格子的选择大概率会少于 4 种，时间复杂度会更低。

综上，最差时间复杂度不超过 $$O(2^k)$$。

*本题恰好是算法课作业遇到的，觉得网上的时间分析和体感不同，稍作改进。*