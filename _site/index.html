<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Hyrule Royal Warehouse | Hyrule Royal Warehouse</title>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hyrule Royal Warehouse | Mundana is a free Jekyll theme for awesome people like you, Medium like.</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Hyrule Royal Warehouse" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A great Jekyll theme developed by Sal @wowthemesnet." />
<meta property="og:description" content="A great Jekyll theme developed by Sal @wowthemesnet." />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Hyrule Royal Warehouse" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hyrule Royal Warehouse" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"A great Jekyll theme developed by Sal @wowthemesnet.","headline":"Hyrule Royal Warehouse","name":"Hyrule Royal Warehouse","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/logo.png"}},"url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

    <!-- Google Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!-- Theme Stylesheet -->
    <link rel="stylesheet" href="/assets/css/theme.css">

    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script
    src="https://code.jquery.com/jquery-3.3.1.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>

    <!-- This goes before </head> closing tag, Google Analytics can be placed here --> 


    

</head>

<body class=" homefirstpage ">

    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <a class="navbar-brand" href="/index.html"><strong>Hyrule Royal Warehouse</strong></a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02" style="">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               <!--  Replace menu links here -->

<li class="nav-item">
<a class="nav-link" href="/index.html">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" href="/authors-list.html">Authors</a>
</li>
<!-- <li class="nav-item">
<a class="nav-link" href="/contact.html">Contact</a>
</li>
<li class="nav-item">
<a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mundana-wordpress/">WP</a>
</li>
<li class="nav-item">
<a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mundana-ghost/">Ghost</a>
</li> -->
<li class="nav-item">
<a target="_blank" class="nav-link" href="https://ko-fi.com/samwitwicky">Buy me a coffee <i class="fa fa-coffee text-danger"></i></a>
</li>

            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <script src="/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});
    

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404/",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about.html",
    "title": "About",
    "body": "Made with by Sal @wowthemesnet. "
    }, {
    "id": 2,
    "url": "http://localhost:4000/author-jane.html",
    "title": "Jane",
    "body": "                        Jane Follow:                                                    Posts by Jane:               "
    }, {
    "id": 3,
    "url": "http://localhost:4000/author-sal.html",
    "title": "Sal",
    "body": "                        Sal Follow:                                                    Posts by Sal:               "
    }, {
    "id": 4,
    "url": "http://localhost:4000/authors-list.html",
    "title": "Authors",
    "body": "Authors:                                             C. R. Zhang :       (View Posts)      Main developer of this site.                           &nbsp;       &nbsp;                                                                             C. Y. Wang :       (View Posts)      Co-blogger of this site.                           &nbsp;       &nbsp;                                      "
    }, {
    "id": 5,
    "url": "http://localhost:4000/buy-me-a-coffee.html",
    "title": "Buy me a coffee",
    "body": "Hi! I am Sal, web designer &amp; developer at WowThemes. net. The free items I create are my side projects and Mundana for Jekyll is one of them. You can find all the work I release for free here. You have my permission to use the free items I develop in your personal, commercial or client projects. If you’d like to reward my work, I would be honored and I could dedicate more time maintaining the free projects. Thank you so much! Buy me a coffee "
    }, {
    "id": 6,
    "url": "http://localhost:4000/categories.html",
    "title": "Categories",
    "body": "          Categories               入门:                                  		关于本站 - About This Website	: 		  Welcome to Hyrule Royal Warehouse. 	 			In 				入门, 				Start, 								Nov 10, 2025						                              Start:                                  		关于本站 - About This Website	: 		  Welcome to Hyrule Royal Warehouse. 	 			In 				入门, 				Start, 								Nov 10, 2025						                              算法:                                  		文件管理模拟 - TJU操作系统课设方案	: 		  文件管理模拟系统 设计方案报告	 			In 				算法, 								Dec 26, 2025						                                 		电梯调度 - TJU操作系统课设方案	: 		  开发环境	 			In 				算法, 								Dec 15, 2025						                                 		力扣第1219题黄金矿工时间复杂度新解	: 		  算法思路	 			In 				算法, 								Dec 11, 2025						                              Algorithm:                                  		A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold	: 		  Algorithm Approach	 			In 				Algorithm, 								Dec 15, 2025						                                 		Elevator Scheduling - Tongji University Operating System Course Project	: 		  Development Environment	 			In 				Algorithm, 								Dec 14, 2025						                              理论:                                  		多核体系下Cache目录一致性协议优化方案	: 		  在多核系统结构下，Cache一致性协议有监听协议和目录协议两种，其中后者是更优的。在经典的目录中，每一个数据块都有对应的目录项，这使得存储的空间开销很大。故而可以使用稀疏目录，通过只维护被Cache缓存的数据对应的信息来减少开销。稀疏目录中的Cuckoo目录是一种较好的方案，它使用哈希表的方式对稀疏目录进行改进。一种潜力更好的目录是Stash目录，它在目录中增加了. . . 	 			In 				理论, 								Dec 16, 2025						                              Theory:                                  		Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures	: 		  In multi-core system architectures, cache coherence protocols are primarily classified into snooping protocols and directory protocols, with the latter generally being considered supe. . . 	 			In 				Theory, 								Dec 17, 2025						                              Algorithms:                                  		File Management Simulation - TJU Operating Systems Course Project	: 		  File Management Simulation System Design Report	 			In 				Algorithms, 								Dec 27, 2025						                                             Featured:    				                                          A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold                          In                     Algorithm,                                                                   "
    }, {
    "id": 7,
    "url": "http://localhost:4000/contact.html",
    "title": "Contact",
    "body": "  Please send your message to Hyrule Royal Warehouse. We will reply as soon as possible!   "
    }, {
    "id": 8,
    "url": "http://localhost:4000/",
    "title": "Hyrule Royal Warehouse",
    "body": "                                  File Management Simulation - TJU Operating Systems Course Project  :       File Management Simulation System Design Report                               Algorithms,                                        Dec 27, 2025                                                                                                                             文件管理模拟 - TJU操作系统课设方案          :                                               算法,                                                                  Dec 26, 2025                                                                                                                                     Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures          :                                               Theory,                                                                  Dec 17, 2025                                                                                                                                    多核体系下Cache目录一致性协议优化方案          :                                               理论,                                                                  Dec 16, 2025                                                           关于本站 - About This Website                  Welcome to Hyrule Royal Warehouse.                 Read More            	                               All:                   		File Management Simulation - TJU Operating Systems Course Project	: 		  File Management Simulation System Design Report	 			In 				Algorithms, 								Dec 27, 2025						                  		文件管理模拟 - TJU操作系统课设方案	: 		  文件管理模拟系统 设计方案报告	 			In 				算法, 								Dec 26, 2025						                  		Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures	: 		  In multi-core system architectures, cache coherence protocols are primarily classified into snooping protocols and directory protocols, with the latter generally being considered supe. . . 	 			In 				Theory, 								Dec 17, 2025						                  		多核体系下Cache目录一致性协议优化方案	: 		  在多核系统结构下，Cache一致性协议有监听协议和目录协议两种，其中后者是更优的。在经典的目录中，每一个数据块都有对应的目录项，这使得存储的空间开销很大。故而可以使用稀疏目录，通过只维护被Cache缓存的数据对应的信息来减少开销。稀疏目录中的Cuckoo目录是一种较好的方案，它使用哈希表的方式对稀疏目录进行改进。一种潜力更好的目录是Stash目录，它在目录中增加了. . . 	 			In 				理论, 								Dec 16, 2025						                  		A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold	: 		  Algorithm Approach	 			In 				Algorithm, 								Dec 15, 2025						                  		电梯调度 - TJU操作系统课设方案	: 		  开发环境	 			In 				算法, 								Dec 15, 2025						                  		Elevator Scheduling - Tongji University Operating System Course Project	: 		  Development Environment	 			In 				Algorithm, 								Dec 14, 2025						                  		力扣第1219题黄金矿工时间复杂度新解	: 		  算法思路	 			In 				算法, 								Dec 11, 2025						                  		关于本站 - About This Website	: 		  Welcome to Hyrule Royal Warehouse. 	 			In 				入门, 				Start, 								Nov 10, 2025						                                                  Featured:    				                                          A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold                          In                     Algorithm,                                                               "
    }, {
    "id": 9,
    "url": "http://localhost:4000/index.html.bk",
    "title": "Mundana Free Jekyll Theme",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More            	             {% endif %}{% endfor %}  {% endif %}                All Stories:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 10,
    "url": "http://localhost:4000/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "”{{site. name}}” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google’s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 11,
    "url": "http://localhost:4000/tags.html",
    "title": "Tags",
    "body": "          Tags          {% for tag in site. tags %}     {{ tag[0] }}:           {% assign pages_list = tag[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 12,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 13,
    "url": "http://localhost:4000/FileManage-en/",
    "title": "File Management Simulation - TJU Operating Systems Course Project",
    "body": "2025/12/27 - File Management Simulation System Design Report: Table of Contents:  File Management Simulation System Design Report     Table of Contents   Development Environment   Project Structure   User Interface   Operation Instructions   Implemented Features   System Analysis         Implemented Classes     Explicit Linking Method     Bitmap and FAT Table          System Implementation         Allocating Disk Space for File Content     Retrieving File Content     Deleting File Content     Updating File Content     Checking for Duplicate Filenames in the Same Directory     Saving File Content     Creating Directory Tree     Disk File Read and Write Operations     Directory File Read and Write Operations          Development Environment:  Development Environment: Windows 11 Development Software: PyCharm Programming Language: Python 3. 11 Main Imported Modules:     PyQt5   sys   os   Project Structure: FileManageSystem/  BitMapInfo. txt  Category. py  CategoryInfo. txt  FCB. py  main. py  MyDiskInfo. txt  project_structure. txt  VirtualDisk. py  Runtime Screenshot. png  docs/    File Management Simulation System Design Report. md  res/    cat. jpg    file. png    folder. jpg    icon. jpgUser Interface: Operation Instructions:  Click the buttons on the right side to create new files, folders, or format the disk; Right-click on blank areas to create new files or folders; Right-click on file or folder names to open or delete files and folders; Click on file or folder names to open the file editor or navigate into folders; When exiting the file editor, you can choose whether to save changes; The upper right section of the interface allows you to enter a name, select a type, and search within the current directory; Files and folders can be sorted by file type, filename, and modification date. Implemented Features:    Display information about files and folders in the current directory;   Create and delete files and folders; Open folders and edit files; Format the disk; Search for files and folders; Tree-structured directory diagram; Sort files and folders by filename, modification time, and file type; Navigate to parent directory; Display current path. System Analysis: Implemented Classes:    FCB Class: File Control Block, records filename, file type, modification date, file size, and starting storage location on disk;     Node Class: Stores child nodes, records parent node, representing relationships between files;     Category Class: Stores directory information for the entire file system, with root recording the root node. Provides several methods:          free_category(self, p_node): Releases the directory of a specified node;           search(self, p_node, file_name, file_type): Searches for files or folders under a specified node;           search_in_current_directory(self, p_node, file_name, file_type): Searches for files or folders only in the specified directory;           create_file(self, parent_node, fcb): Creates files or folders;           check_same_name(self, p_node, name, file_type): Checks if a file or folder with the same name exists in the same directory.        VirtualDisk Class: Simulates disk operations, recording disk size, block size, number of blocks, remaining blocks, memory and bitmap. Provides several methods:     get_block_size(self, size): Returns the number of storage blocks required for a specified size;   give_space(self, fcb, content): Allocates space for storing content for a specific FCB, writes content to disk, and updates the bitmap;   get_file_content(self,fcb): Returns the content stored on disk for a specified FCB;   delete_file_content(self, start, size): Deletes content stored on disk at a specified starting position and size;   file_update(self,old_start,old_size,new_fcb,new_content): Updates file content.     MainWindow Class: Main window, maintains primary program logic; HelpDialog Class: Help window, displays when the file management system is first opened, providing operational guidance to users; CreateDialog Class: New file and folder creation window, displays when creating new files and folders; NoteForm Class: Text file editing interface, displays when editing text files;Explicit Linking Method:  In this file system, file storage space management uses the explicit linking method. File content is stored in different blocks on the disk. When creating a file, an appropriate number of free blocks are allocated. When writing to a file, content is written sequentially into corresponding blocks; when deleting a file, the previously occupied positions are simply marked as empty. Bitmap and FAT Table:  Disk free space management is based on an enhanced bitmap design. The FAT table, which stores file location information on the disk, is combined with a traditional bitmap. Empty disk positions are marked with EMPTY = -1, blocks containing files store the position of the next block in the file, and blocks at the end of files are marked with END = -2. System Implementation: Allocating Disk Space for File Content: def give_space(self, fcb, content):    blocks = []    index = 0    while index &lt; len(content):      # Special handling for newlines to ensure '\r\n' is not split      if content[index:index + 2] == '\r\n' and self. block_size == 2 and index + 2 &lt;= len(content):        blocks. append(content[index:index + 2])        index += 2      elif index + self. block_size &lt;= len(content):        blocks. append(content[index:index + self. block_size])        index += self. block_size      else:        # Add the last possible block smaller than block_size        blocks. append(content[index:])        break    if not blocks: # If blocks is empty (content is empty or other cases)      return True     if len(blocks) &lt;= self. remain:      # Find where to start storing the file      start = -1      for i in range(self. block_num):        if self. bit_map[i] == self. EMPTY:          self. remain -= 1          start = i          fcb. start = i          self. memory[i] = blocks[0]          break      if start == -1: # If no space found        return False      # Start storing content from this position onward      j = 1      i = start + 1      while j &lt; len(blocks) and i &lt; self. block_num:        if self. bit_map[i] == self. EMPTY:          self. remain -= 1          self. bit_map[start] = i # Store each piece of data using linking          start = i          self. memory[i] = blocks[j]          j += 1 # Process next block        i += 1      if j == len(blocks):        self. bit_map[start] = self. END # Mark end of file      return True    else:      return FalseFirst, the content is split to ensure text is divided according to the given block size, while ensuring that \r\n newline characters are not split across different blocks. Then, the disk is traversed to find the first free storage block, its position is recorded in fcb. start, content is written into it, and the remaining block count is decremented. Next, content continues to be stored from this position onward. In the bitmap, block relationships are stored using linking - each position in the bitmap stores the position of the next block, with the end of file marked by self. END. Retrieving File Content: def get_file_content(self,fcb):    if fcb. start == self. EMPTY:      return       else:      content =         start = fcb. start      blocks = self. get_block_size(fcb. size)      count = 0      i=start      while i&lt;self. block_num and count &lt; blocks:        content += self. memory[i]        i=self. bit_map[i]        count+=1    return contentBased on information stored in the bitmap, content from different storage blocks is concatenated together. Deleting File Content: def delete_file_content(self, start, size):    if start == self. EMPTY or start &gt;= self. block_num:      return # If start position is invalid or file is empty, return immediately    blocks = self. get_block_size(size)    count = 0    i = start    while i &lt; self. block_num and count &lt; blocks:      next_index = self. bit_map[i] # Get next index before clearing      self. memory[i] =         self. bit_map[i] = self. EMPTY      self. remain += 1      if next_index == self. END:        break # If this was the last block, exit the loop      i = next_index      count += 1Updating File Content: def file_update(self,old_start,old_size,new_fcb,new_content):  self. delete_file_content(old_start,old_size)  return self. give_space(new_fcb,new_content)Checking for Duplicate Filenames in the Same Directory: def check_same_name(self, p_node, name, file_type):    if p_node is None:      return True    # Only check direct children of the given node (parent node)    for child in p_node. children:      if child. fcb. file_name == name and child. fcb. file_type == file_type:        return False # Found a direct child with the same name and type, return False    return True # No file with the same name and type found in the same directory, return TrueSaving File Content:   def save_content(self):    content = self. textEdit. toPlainText()    fcb = self. main_form. category. search(self. main_form. current_node, self. filename, FCB. TXTFILE). fcb    old_size = fcb. size    new_size = len(content)    current_time = datetime. now(). strftime( %Y-%m-%d %H:%M:%S )    # Update file size and modification time    fcb. size = new_size    fcb. last_modify = current_time    # Attempt to update the file content on the disk    if not self. main_form. disk. file_update(fcb. start, old_size, fcb, content):      QMessageBox. critical(self, 'Error', 'Failed to save file on disk. ')    else:      QMessageBox. information(self, 'Success', 'File saved successfully. ')      self. main_form. write_my_disk()      self. main_form. write_bit_map()      self. main_form. write_category()Creating Directory Tree:   def create_tree(self):    # Clear existing items in the tree    self. tree. clear()    # Define a recursive function to add items    def add_items(parent_item, node):      # Create a tree item for the current node      item = QTreeWidgetItem(parent_item, [node. fcb. file_name])      # Recursively add tree items for each child node      for child in node. children:        add_items(item, child)    # Check if root node exists    if self. category. root is not None:      # Create tree item corresponding to root node      root_item = QTreeWidgetItem(self. tree, [self. category. root. fcb. file_name +   (Root) ])      self. tree. addTopLevelItem(root_item)      # Add tree items for each child of the root node      for child in self. category. root. children:        add_items(root_item, child)      # Expand root node to display all child nodes by default      root_item. setExpanded(True)    else:      print( No root node is defined in the category.  )Disk File Read and Write Operations:   def read_my_disk(self):    path = os. path. join(os. getcwd(),  MyDiskInfo. txt )    if os. path. exists(path):      with open(path, 'r', encoding='utf-8') as reader:        # First read disk remaining capacity information        remain_line = reader. readline(). strip()        if remain_line. startswith( Remaining Blocks: ):          self. disk. remain = int(remain_line. split( : )[1]. strip())        for i in range(self. disk. block_num):          line = reader. readline()          #if line == '\n': # Check if it's a blank line with only newline character            #continue          # Decode the line, handling all types of newlines          line = line. rstrip( \n ) # Remove only the newline at the end          line = line. replace( ||| ,  \r\n ). replace( |r| ,  \r ). replace( |n| ,  \n )          self. disk. memory[i] = line  def write_my_disk(self):    path = os. path. join(os. getcwd(),  MyDiskInfo. txt )    if os. path. exists(path):      os. remove(path)    with open(path, 'w', encoding='utf-8') as writer:      # Write disk remaining capacity      writer. write(f Remaining Blocks: {self. disk. remain}\n )      for data in self. disk. memory:        # Output original data about to be encoded        print( Original data: , repr(data))        # Encode the line, handling all types of newlines        encoded_data = data. replace( \r\n ,  ||| ). replace( \r ,  |r| ). replace( \n ,  |n| )        # Print encoded data to confirm correct conversion        print( Encoded data: , repr(encoded_data))        writer. write(encoded_data + '\n') # Write converted data plus line separatorSpecial encoding is applied to special characters “\r\n”, “\r”, “\n”. During reading, line = reader. readline() is used to ensure reading the entire line including newline characters, then line = line. rstrip( \n ) removes the trailing newline. Directory File Read and Write Operations:   def read_category(self):    with open( CategoryInfo. txt , 'r') as file:      lines = file. readlines()      root_node = None      parent_stack = []      current_node_info = {}      for line in lines:        line = line. strip()        if  Node Start  in line:          current_node_info = {}        elif  Node End  in line:          fcb = FCB(current_node_info['File Name'],               int(current_node_info['File Type']),               current_node_info['Last Modified'],               int(current_node_info['File Size']),               int(current_node_info['Start Position']))          new_node = Category. Node(fcb)          if parent_stack:            parent_stack[-1]. add_child(new_node)          else:            root_node = new_node # Mark as root node          parent_stack. append(new_node) # Add current node to stack as parent for subsequent child nodes        elif  Parent End  in line and parent_stack:          parent_stack. pop() # When all child nodes of a node have been processed, remove that node from stack        else:          if line:            parts = line. split( :  , 1)            if len(parts) == 2:              key, value = parts              current_node_info[key. strip()] = value. strip()    if not root_node:      default_fcb = FCB( root , FCB. FOLDER,   , 0)      root_node = Category. Node(default_fcb)    self. category. root = root_node    self. root_node = root_node    self. current_node = root_node    self. file_form_init(self. category. root)  def write_category(self):    with open( CategoryInfo. txt , 'w') as file:      def write_node(node, parent_name=  ):        file. write( Node Start\n )        file. write(f Parent Name: {parent_name}\n )        file. write(f File Name: {node. fcb. file_name}\n )        file. write(f File Type: {node. fcb. file_type}\n )        file. write(f Last Modified: {node. fcb. last_modify}\n )        file. write(f File Size: {node. fcb. size}\n )        file. write(f Start Position: {node. fcb. start}\n )        file. write( Node End\n )        for child in node. children:          write_node(child, node. fcb. file_name)        file. write( Parent End\n ) # Mark end of parent node      if self. category. root:        write_node(self. category. root)The directory structure and file information are written to the directory file. If the directory structure is as follows: Then the content of the directory file will be: Node StartParent Name: File Name: rootFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndNode StartParent Name: rootFile Name: docsFile Type: 1Last Modified: 2024-04-17 23:24:37File Size: 0Start Position: -1Node EndParent EndNode StartParent Name: rootFile Name: resFile Type: 1Last Modified: 2024-04-17 23:25:04File Size: 0Start Position: -1Node EndNode StartParent Name: resFile Name: testFile Type: 1Last Modified: 2024-04-17 23:24:58File Size: 0Start Position: -1Node EndParent EndNode StartParent Name: resFile Name: projectFile Type: 1Last Modified: 2024-04-17 23:25:04File Size: 0Start Position: -1Node EndParent EndParent EndNode StartParent Name: rootFile Name: yikFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndNode StartParent Name: yikFile Name: codeFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndParent EndParent EndParent EndTo better illustrate the principle, the above file content with indentation added: Node StartParent Name: File Name: rootFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node End  Node Start  Parent Name: root  File Name: docs  File Type: 1  Last Modified: 2024-04-17 23:24:37  File Size: 0  Start Position: -1  Node End  Parent End  Node Start  Parent Name: root  File Name: res  File Type: 1  Last Modified: 2024-04-17 23:25:04  File Size: 0  Start Position: -1  Node End    Node Start    Parent Name: res    File Name: test    File Type: 1    Last Modified: 2024-04-17 23:24:58    File Size: 0    Start Position: -1    Node End    Parent End    Node Start    Parent Name: res    File Name: project    File Type: 1    Last Modified: 2024-04-17 23:25:04    File Size: 0    Start Position: -1    Node End    Parent End  Parent End  Node Start  Parent Name: root  File Name: yik  File Type: 1  Last Modified: 2024-04-17 23:25:17  File Size: 0  Start Position: -1  Node End    Node Start    Parent Name: yik    File Name: code    File Type: 1    Last Modified: 2024-04-17 23:25:17    File Size: 0    Start Position: -1    Node End    Parent End  Parent EndParent EndThe file exhibits the following characteristics:  Each node starts with a “Node Start” marker and ends with a “Node End” marker; When all child nodes of a node have been listed, “Parent End” is output;These characteristics can also be obtained through the write_category(self) function; Next, the principle of the read_category(self) function is explained:  First, all data from the directory file is read; Process the read data line by line:     If the line contains “Node Start”, clear current_node_info to prepare for reading new node data;   If it’s other node information, split the data to obtain key and value;   If the line contains “Node End”, it indicates all information for a node has been read. Create the node and add it as a child node to the current parent node (top element of stack). If the stack is empty at this point, this node is the root node. Finally, push this node onto the stack to serve as the parent for subsequent nodes;   If the line contains “Parent End”, it indicates all child nodes of the current parent have been processed, so pop the top element from the stack;    If there is no root node information, create a default root node; Set the root node of the directory;"
    }, {
    "id": 14,
    "url": "http://localhost:4000/FileManage/",
    "title": "文件管理模拟 - TJU操作系统课设方案",
    "body": "2025/12/26 - 文件管理模拟系统 设计方案报告: 目录:  文件管理模拟系统 设计方案报告     目录   开发环境   项目结构   界面   操作说明   实现的功能   系统分析         实现的类     显式链接法     位图、FAT表          系统实现         为文件内容分配磁盘空间     获取文件内容     删除文件内容     更新文件内容     检查同目录下是否有同名文件     保存文件内容     创建目录树     磁盘文件的写入和读取     目录文件的写入和读取          开发环境:  开发环境：Windows 11 开发软件：Pycharm 开发语言：Python 3. 11 主要引用模块：     PyQt5   sys   os   项目结构: FileManageSystem/  BitMapInfo. txt  Category. py  CategoryInfo. txt  FCB. py  main. py  MyDiskInfo. txt  project_structure. txt  VirtualDisk. py  运行时截图. png  docs/    文件管理模拟系统 设计方案报告. md  res/    cat. jpg    file. png    folder. jpg    icon. jpg界面: 操作说明:  点击右侧按钮可以新建文件，文件夹，格式化磁盘； 当用鼠标右键点击空白区域时，可以新建文件或文件夹； 当用鼠标右键点击文件或文件夹名称时，可以打开或者删除文件和文件夹； 点击文件或文件夹名可以打开文件编辑框或者打开文件夹； 当退出文件编辑框时可以选择是否保存修改； 界面右侧上方可以输入名称，选择类型，然后在当前目录下进行搜索； 可以按文件类型，文件名和修改日期对文件夹和文件进行排序。实现的功能:    当前目录下文件和文件夹信息的显示；   文件和文件夹的创建与删除； 文件夹的打开，文件的编辑； 格式化磁盘； 文件和文件夹的搜索； 树状目录结构示意图； 按文件名，修改实现，文件类型排列文件和文件夹； 返回上级目录； 当前路径的显示。系统分析: 实现的类:    FCB类：文件控制块，记录文件名称，文件类型，修改日期，文件大小，在磁盘中的起始存储位置；     Node类：存储子节点，记录父节点，映射为文件之间的关系；     Category类：存储整个文件系统的目录信息，其中的root记录了根节点，提供了一些方法：          free_category(self, p_node)：释放指定节点的目录；           search(self, p_node, file_name, file_type)：在指定节点下搜索文件或文件夹；           search_in_current_directory(self, p_node, file_name, file_type)：只在指定目录下搜索文件或文件夹；           create_file(self, parent_node, fcb)：创建文件或文件夹；           check_same_name(self, p_node, name, file_type)：判断在同一目录下是否存在同名文件或文件夹。        VirtualDisk类：模拟对磁盘的操作，记录了磁盘大小，存储块大小，存储块数量，剩余存储块数量，内存和位图，提供了一些方法：     get_block_size(self, size)：得到指定大小所要占用的存储块数量；   give_space(self, fcb, content)：为特定fcb分配存储content的空间，将内容写入磁盘中，并对位图做出修改；   get_file_content(self,fcb)：返回指定fcb在存储在磁盘中的内容；   delete_file_content(self, start, size)：删除指定起始位置和大小存储在磁盘上的内容；   file_update(self,old_start,old_size,new_fcb,new_content)：更新文件内容。    MainWindow类：主窗口，维护了主要的程序逻辑； HelpDialog类：操作帮助窗口，在初次打开文件管理系统时弹出，给用户提供操作帮助； CreateDialog类：新建文件和文件夹窗口，在新建文件和文件夹时弹出； NoteForm类：编辑文本文件的界面，在编辑文本文件时弹出；显式链接法:  本文件系统中, 文件存储空间管理使用显示链接的方法，文件中的内容存放在磁盘不同的块中，每次创建文件时为文件分配数量合适的空闲块。每次写文件时按顺序将文件内容写在相应块中; 删除文件时将原先有内 容的位置置为空即可。位图、FAT表:  磁盘空闲空间管理在位图的基础上进行改造，将存放磁盘上文件位置信息的FAT表与传统的位图进行结合， 磁盘空闲的位置使用EMPTY = -1标识，放有文件的盘块存放文件所在的下一个盘块的位置，文件存放结 束的盘块位置使用END = -2标识。系统实现: 为文件内容分配磁盘空间: def give_space(self, fcb, content):    blocks = []    index = 0    while index &lt; len(content):      # 特别处理换行符，保证'\r\n'不被拆分      if content[index:index + 2] == '\r\n' and self. block_size == 2 and index + 2 &lt;= len(content):        blocks. append(content[index:index + 2])        index += 2      elif index + self. block_size &lt;= len(content):        blocks. append(content[index:index + self. block_size])        index += self. block_size      else:        # 添加最后一个可能的小于block_size的块        blocks. append(content[index:])        break    if not blocks: # 如果blocks为空（content为空或其他情况）      return True     if len(blocks) &lt;= self. remain:      # 找到文件开始存放的位置      start = -1      for i in range(self. block_num):        if self. bit_map[i] == self. EMPTY:          self. remain -= 1          start = i          fcb. start = i          self. memory[i] = blocks[0]          break      if start == -1: # 如果没有找到空间        return False      # 从该位置往后开始存放内容      j = 1      i = start + 1      while j &lt; len(blocks) and i &lt; self. block_num:        if self. bit_map[i] == self. EMPTY:          self. remain -= 1          self. bit_map[start] = i # 以链接的方式存储每位数据          start = i          self. memory[i] = blocks[j]          j += 1 # 处理下一个块        i += 1      if j == len(blocks):        self. bit_map[start] = self. END # 标记文件尾      return True    else:      return False首先将content进行分割，确保文本按照给定的块大小被分割，同时不会将 \r\n 换行符拆分到不同的块中。然后遍历磁盘，找到第一个空闲的存储块，将它的位置记录到fcb. start中，并往里面写入内容，同时将剩余的存储块数量减一。接着从该位置往后开始存放内容，在位图中以链接的方式存储块之间的联系，位图中的每一位存储下一个块的位置，文件尾用self. END表示。 获取文件内容: def get_file_content(self,fcb):    if fcb. start == self. EMPTY:      return       else:      content =         start = fcb. start      blocks = self. get_block_size(fcb. size)      count = 0      i=start      while i&lt;self. block_num and count &lt; blocks:        content += self. memory[i]        i=self. bit_map[i]        count+=1    return content根据位图中存储的信息将不同存储块里的内容拼接在一起。 删除文件内容: def delete_file_content(self, start, size):    if start == self. EMPTY or start &gt;= self. block_num:      return # If start position is invalid or file is empty, return immediately    blocks = self. get_block_size(size)    count = 0    i = start    while i &lt; self. block_num and count &lt; blocks:      next_index = self. bit_map[i] # Get next index before clearing      self. memory[i] =         self. bit_map[i] = self. EMPTY      self. remain += 1      if next_index == self. END:        break # If this was the last block, exit the loop      i = next_index      count += 1更新文件内容: def file_update(self,old_start,old_size,new_fcb,new_content):  self. delete_file_content(old_start,old_size)  return self. give_space(new_fcb,new_content)检查同目录下是否有同名文件: def check_same_name(self, p_node, name, file_type):    if p_node is None:      return True    # 只检查给定节点（即父节点）的直接子节点    for child in p_node. children:      if child. fcb. file_name == name and child. fcb. file_type == file_type:        return False # 找到一个同名同类型的直接子节点，返回 False    return True # 在同级目录中没有找到同名同类型的文件，返回 True保存文件内容:   def save_content(self):    content = self. textEdit. toPlainText()    fcb = self. main_form. category. search(self. main_form. current_node, self. filename, FCB. TXTFILE). fcb    old_size = fcb. size    new_size = len(content)    current_time = datetime. now(). strftime( %Y-%m-%d %H:%M:%S )    # Update file size and modification time    fcb. size = new_size    fcb. last_modify = current_time    # Attempt to update the file content on the disk    if not self. main_form. disk. file_update(fcb. start, old_size, fcb, content):      QMessageBox. critical(self, 'Error', 'Failed to save file on disk. ')    else:      QMessageBox. information(self, 'Success', 'File saved successfully. ')    # Update the modification time for all parent nodes    node = self. main_form. category. search(self. main_form. current_node, self. filename, FCB. TXTFILE)    while node. parent:      node. parent. fcb. last_modify = current_time      node = node. parent    self. main_form. update_disk_info()    # Assume a method to update the UI to reflect changes    self. main_form. display_file_folder_info(fcb. file_name, fcb. last_modify, fcb. file_type, fcb. size)    #self. main_form. file_form_init(self. main_form. current_node) # Refresh the view to show updated times创建目录树:   def setup_tree(self):    # 清除现有的树结构    self. tree. clear()    # 创建一个递归函数来填充树视图    def add_items(parent_item, node):      # 根据当前节点的信息创建一个新的树项目      if node. fcb. file_type == FCB. FOLDER:        item = QTreeWidgetItem(parent_item, [node. fcb. file_name +   (Folder) ])      else:        item = QTreeWidgetItem(parent_item, [node. fcb. file_name +   (File) ])      # 递归地为每个子节点添加树项目      for child in node. children:        add_items(item, child)    # 检查根节点是否存在    if self. category. root is not None:      # 创建根节点对应的树项目      root_item = QTreeWidgetItem(self. tree, [self. category. root. fcb. file_name +   (Root) ])      self. tree. addTopLevelItem(root_item)      # 为根节点的每个子节点添加树项目      for child in self. category. root. children:        add_items(root_item, child)      # 展开根节点，以便默认显示所有子节点      root_item. setExpanded(True)    else:      print( No root node is defined in the category.  )磁盘文件的写入和读取:   def read_my_disk(self):    path = os. path. join(os. getcwd(),  MyDiskInfo. txt )    if os. path. exists(path):      with open(path, 'r', encoding='utf-8') as reader:        # 首先读取磁盘的剩余容量信息        remain_line = reader. readline(). strip()        if remain_line. startswith( Remaining Blocks: ):          self. disk. remain = int(remain_line. split( : )[1]. strip())        for i in range(self. disk. block_num):          line = reader. readline()          #if line == '\n': # 检查是否是空行，只有换行符的行            #continue          # Decode the line, handling all types of newlines          line = line. rstrip( \n ) # Remove only the newline at the end          line = line. replace( ||| ,  \r\n ). replace( |r| ,  \r ). replace( |n| ,  \n )          self. disk. memory[i] = line  def write_my_disk(self):    path = os. path. join(os. getcwd(),  MyDiskInfo. txt )    if os. path. exists(path):      os. remove(path)    with open(path, 'w', encoding='utf-8') as writer:      # 写入磁盘的剩余容量      writer. write(f Remaining Blocks: {self. disk. remain}\n )      for data in self. disk. memory:        # 输出即将被编码的原始数据        print( Original data: , repr(data))        # Encode the line, handling all types of newlines        encoded_data = data. replace( \r\n ,  ||| ). replace( \r ,  |r| ). replace( \n ,  |n| )        # 打印编码后的数据以确认转换正确        print( Encoded data: , repr(encoded_data))        writer. write(encoded_data + '\n') # 写入转换后的数据加上行分隔符对特殊字符,”\r\n”，”\r”，”\n”进行特殊编码处理，在读入时使用line = reader. readline()保证读取整行数据，包括换行符，再用line = line. rstrip(“\n”) 移除行末换行符。 目录文件的写入和读取:   def read_category(self):    with open( CategoryInfo. txt , 'r') as file:      lines = file. readlines()      root_node = None      parent_stack = []      current_node_info = {}      for line in lines:        line = line. strip()        if  Node Start  in line:          current_node_info = {}        elif  Node End  in line:          fcb = FCB(current_node_info['File Name'],               int(current_node_info['File Type']),               current_node_info['Last Modified'],               int(current_node_info['File Size']),               int(current_node_info['Start Position']))          new_node = Category. Node(fcb)          if parent_stack:            parent_stack[-1]. add_child(new_node)          else:            root_node = new_node # 标记根节点          parent_stack. append(new_node) # 添加当前节点到栈，用作后续子节点的父节点        elif  Parent End  in line and parent_stack:          parent_stack. pop() # 当一个节点的所有子节点都被处理完毕，从栈中移除该节点        else:          if line:            parts = line. split( :  , 1)            if len(parts) == 2:              key, value = parts              current_node_info[key. strip()] = value. strip()    if not root_node:      default_fcb = FCB( root , FCB. FOLDER,   , 0)      root_node = Category. Node(default_fcb)    self. category. root = root_node    self. root_node = root_node    self. current_node = root_node    self. file_form_init(self. category. root)  def write_category(self):    with open( CategoryInfo. txt , 'w') as file:      def write_node(node, parent_name=  ):        file. write( Node Start\n )        file. write(f Parent Name: {parent_name}\n )        file. write(f File Name: {node. fcb. file_name}\n )        file. write(f File Type: {node. fcb. file_type}\n )        file. write(f Last Modified: {node. fcb. last_modify}\n )        file. write(f File Size: {node. fcb. size}\n )        file. write(f Start Position: {node. fcb. start}\n )        file. write( Node End\n )        for child in node. children:          write_node(child, node. fcb. file_name)        file. write( Parent End\n ) # 标记父节点的结束      if self. category. root:        write_node(self. category. root)将目录结构和文件信息写入目录文件中，如果目录结构如下： 那么目录文件的内容为： Node StartParent Name: File Name: rootFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndNode StartParent Name: rootFile Name: docsFile Type: 1Last Modified: 2024-04-17 23:24:37File Size: 0Start Position: -1Node EndParent EndNode StartParent Name: rootFile Name: resFile Type: 1Last Modified: 2024-04-17 23:25:04File Size: 0Start Position: -1Node EndNode StartParent Name: resFile Name: testFile Type: 1Last Modified: 2024-04-17 23:24:58File Size: 0Start Position: -1Node EndParent EndNode StartParent Name: resFile Name: projectFile Type: 1Last Modified: 2024-04-17 23:25:04File Size: 0Start Position: -1Node EndParent EndParent EndNode StartParent Name: rootFile Name: yikFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndNode StartParent Name: yikFile Name: codeFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node EndParent EndParent EndParent End为了方便说明原理，对上面文件内容添加缩进： Node StartParent Name: File Name: rootFile Type: 1Last Modified: 2024-04-17 23:25:17File Size: 0Start Position: -1Node End  Node Start  Parent Name: root  File Name: docs  File Type: 1  Last Modified: 2024-04-17 23:24:37  File Size: 0  Start Position: -1  Node End  Parent End  Node Start  Parent Name: root  File Name: res  File Type: 1  Last Modified: 2024-04-17 23:25:04  File Size: 0  Start Position: -1  Node End    Node Start    Parent Name: res    File Name: test    File Type: 1    Last Modified: 2024-04-17 23:24:58    File Size: 0    Start Position: -1    Node End    Parent End    Node Start    Parent Name: res    File Name: project    File Type: 1    Last Modified: 2024-04-17 23:25:04    File Size: 0    Start Position: -1    Node End    Parent End  Parent End  Node Start  Parent Name: root  File Name: yik  File Type: 1  Last Modified: 2024-04-17 23:25:17  File Size: 0  Start Position: -1  Node End    Node Start    Parent Name: yik    File Name: code    File Type: 1    Last Modified: 2024-04-17 23:25:17    File Size: 0    Start Position: -1    Node End    Parent End  Parent EndParent End可以看出，该文件具有以下特点：  每个节点以Node Start标记开始，以Node End标记结束； 当一个节点的子节点全部被列出时，输出Parent End；这些特点也可以通过write_category(self)函数获得； 接下来说明函数read_category(self)的原理：  首先读入目录文件中的所有数据； 逐行处理读入的数据：     如果该行包括”Node Start”，将current_node_info清空，准备读入新节点的数据；   如果是节点的其它信息，则对数据进行分割，获得key和value；   如果该行包括”Node End”，说明一个节点的信息已经全部读入，创建该节点，并把它作为子节点添加到当前的父节点（栈顶元素）下，如果此时栈为空，说明该节点就是根节点。最后，把该节点入栈，作为后续节点的根节点；   如果该行包括”Parent End”，说明当前父节点的所有子节点都已经处理完，弹出栈顶元素；    如果没有根节点信息，创建一个默认的根节点； 设置目录的根节点；"
    }, {
    "id": 15,
    "url": "http://localhost:4000/Cache-en/",
    "title": "Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures",
    "body": "2025/12/17 - In multi-core system architectures, cache coherence protocols are primarily classified into snooping protocols and directory protocols, with the latter generally being considered superior. In classic directory schemes, every data block has a corresponding directory entry, which results in significant storage overhead. Consequently, sparse directories can be employed to reduce costs by maintaining information only for data currently cached. The Cuckoo directory, which improves upon the sparse directory using hash tables, represents a robust solution. A potentially superior alternative is the Stash directory, which incorporates a flag bit in the directory to distinguish cache states, further minimizing performance loss. Both sparse directory schemes offer significant improvements over traditional directories. Based on theoretical analysis, their practical feasibility can be further verified through simulation. 1. Introduction: With the evolution of computer systems, multi-core and many-core architectures have become essential for achieving high performance and parallel computing. In multi-core architectures, the Cache serves as a critical component, playing a vital role in accelerating data access and enhancing system performance. However, read and write operations across private caches of multiple cores can lead to inconsistency issues. This has led to the development of numerous coherence protocols, among which the directory coherence protocol stands out for its scalability. Nevertheless, as the number of cores increases and shared data grows, traditional directory-based schemes face the challenge of excessive storage and access overheads. This article analyzes existing sparse directory schemes and their optimization effects on traditional directory-based protocols within the context of distributed storage in homogeneous multi-core architectures, and subsequently proposes further optimization methods. This article first briefly introduces the basic principles of directory coherence protocols used in homogeneous multi-core architectures with distributed storage. It then elaborates on existing schemes that optimize directory structures into sparse directories and presents novel optimization results. Finally, it analyzes the advantages, disadvantages, and feasibility of each scheme. 2. Directory Coherence Protocols in Distributed Storage: The directory coherence protocol is an improvement over the snooping protocol, introducing a “directory” data structure that significantly enhances system scalability. The directory stores relevant information for each data block, making access operations more efficient and avoiding the performance limitations caused by the broadcast mechanism in snooping protocols. When using a classic directory coherence protocol in a distributed shared memory system, each data block has a dedicated entry in the directory. Based on this characteristic, we refer to this as a “Full Directory” for the sake of subsequent discussion. Let us briefly analyze the overhead of a full directory. In this scheme, every node maintains complete directory information. Assuming each node’s memory contains $M$ blocks and there are $N$ nodes in total, each full directory must record $M \times N$ directory entries. Consequently, the directory space overhead for the entire system reaches the order of $O(M \times N \times N)$. Due to the large number of processors, the storage overhead for the directory entries themselves is substantial. As the number of nodes $N$ increases, the space overhead grows quadratically, resulting in poor system scalability. Therefore, we consider reducing the number of directory entries in each node to mitigate the costs of a full directory. This leads to the introduction of the sparse directory as an improved solution. 3. Sparse Directory: 3. 1 Sparse Directory: The definition of a sparse directory was first proposed in 1992. It differs from a full directory in the way entries are allocated. A sparse directory allocates a directory entry only for cache blocks present in the Last Level Cache (LLC), recording the state information of the corresponding cache block. Since only a small fraction of blocks are loaded into various private caches at any given time, the vast majority of directory entries in a full directory are not accessed in the short term. Particularly as the core count increases and storage space expands, the proportion of these unused entries grows. Therefore, the storage overhead for these entries should be reduced. A sparse directory maintains consistency information only for data cached in private caches. Each directory entry includes a tag (indexing the cache block address), a state bit (recording the coherence state), and a sharing list (recording the distribution of data copies across processor cores) [1]. Sparse directories are characterized by low associativity and large directory capacity. The purpose of low associativity is to reduce power consumption during directory lookups, but this increases the probability of set conflicts and the frequency of directory entry replacements. Directory replacements, in turn, cause the corresponding cache blocks to become invalid, forcing all nodes sharing that cache block to perform replacements. This increases access latency and causes data thrashing, thereby degrading system performance. To minimize directory conflict frequency and avoid performance loss, an over-provisioned directory capacity is adopted, reducing intra-set access conflicts by increasing the number of directory sets. 3. 2 Cuckoo Directory and Implementation: Ferdman et al. proposed using the Cuckoo directory to reduce the conflict replacements faced by sparse directories, aiming to solve the forced invalidation and cache thrashing issues caused by set conflicts in traditional schemes. This scheme retains the advantage of reduced storage overhead found in sparse directories while maintaining the stability of each node’s cache to a great extent, making it a relatively ideal sparse directory solution. The implementation of the Cuckoo directory is based on Cuckoo Hashing. The simplest sparse directory uses set associativity to reduce directory entries, which is essentially a form of hashing; therefore, improving sparse directories using hash tables is feasible. Cuckoo Hashing, also known as chained hashing, utilizes two or more parallel hash tables to reduce overhead when hash conflicts occur. Since the primary problem facing sparse directories after overhead reduction is conflict within set-associative directories, using chained hashing to mitigate conflicts is superior. In specific implementations, a 4-way Cuckoo directory structure can be adopted, using different hash functions for each way. When a new block becomes private storage and needs to be added to the directory, an insertion operation is triggered as follows:  Calculate the results of the hash functions for each way.  If a mapped position is empty, insert the entry there (if multiple ways have empty positions, one can be chosen arbitrarily).  If none of the mapped positions are empty, select a way (starting from the first) to insert the new entry and evict the existing directory entry.  Recalculate the hash function results for the evicted directory entry. If a mapped position is empty, execute step 2; otherwise, execute step 3.  If the loop of steps 3 and 4 continues without resolving, stop re-mapping after a certain number of attempts and force the eviction of the entry. Since this effectively invalidates a block in the Cache, it has a certain negative impact on operational efficiency. When querying directory content, one simply maps the block index to be queried using the four-way hash and matches the index at the corresponding positions to determine a hit. Clearly, the time complexity for querying is $O(1)$. although the insertion time depends on the number of replacement cycles, amortized analysis shows that the amortized time for insertion is also $O(1)$ [2]. Thus, the Cuckoo directory possesses high time efficiency. There are several reasons for adopting Cuckoo hashing here rather than a standard hash table. Firstly, while linear probing is the fastest method for resolving conflicts in general hash tables (proven to be 16%-23% faster than Cuckoo hashing [3]), the amortized cost of operations in Cuckoo hashing is $O(1)$, meaning it is not significantly slower in terms of rapid response. Secondly, linear probing tends to cause directory entries to cluster in certain areas, leading to hotspot issues. In contrast, the four-way structure of Cuckoo hashing distributes entries more uniformly across different ways, making it a data structure better suited for computer architecture design. Therefore, the selection of hash functions largely determines the efficiency of the final implementation. The four hash functions must ensure excellent scattering properties so that mapping results are uniform. Simultaneously, due to the principle of locality, block addresses queried by a node within a period are relatively continuous. The hashing results should map continuous addresses to entries that are far apart within the same way; this is necessary to avoid hotspot issues. It is also necessary to minimize the number of loops during replacement cycles; thus, the mapping results of the four-way hash should be distinct. Assuming an address space from 0 to N and N/10 directory entries per way, we analyzed and designed a function mapping method. Figure 2 illustrates the mapping result of this design for the 0-N/10 address space. Based on the principle of locality and the ratio of private cache to total storage, block numbers recorded in the directory at any given moment are generally concentrated within a relatively continuous area of size N/10. In this scenario, a mapping method with a slope of 1 uses different offsets to ensuring that each block has four scattered, distinct hash results. This utilizes scattered directory entries as much as possible at any moment, maximizing the reduction of hotspot issues.  3. 3 Stash Directory: The Cuckoo directory successfully reduces conflicts and hotspots using multiple distinct hash functions. However, when insertion reaches a forced termination state, the final block is kicked out. Essentially, this fails to leverage the principle of locality and thus cannot completely avoid data thrashing. Consequently, Demetriades et al. proposed the Stash directory [4]. Consider a Cache block in an exclusive state; read and write operations on this block do not need to be restricted until another node requests it. The Stash directory exploits this characteristic by categorizing cached blocks into two distinct states: “Exclusive” and “Shared,” adding a 1-bit flag in the directory to distinguish them. Typically, we use 0 for “Exclusive” and 1 for “Shared. ” From a hardware perspective, since any new directory entry added is initially in an exclusive state and the memory’s initial state is generally 0, this bit can be recorded without extra operations, making the 0-1 correspondence logical. Consider the case where a directory entry is replaced. If the flag indicates the block is in an “Exclusive” state, the block is not actually evicted from the Cache. This is because the node holding it exclusively will not cause consistency issues regardless of how it reads or writes, until another node requests that block. When another node calls for this block, since the record for it no longer exists in the directory, the system might erroneously conclude that the block is not in any node’s private cache. This is known as a False Miss. To avoid False Misses, a flag bit must be added to each Cache block in the shared LLC to indicate whether the corresponding Cache block has been cached by a lower-level Cache. This provides a new method to further determine the true state of each block.  The Stash directory utilizes the shared LLC and coherence protocols to detect issues like False Misses. The shared LLC reserves a False Miss Tag bit for each cache block to indicate if the block might be “cached” at a lower level of the hierarchy. Whenever a directory entry is evicted without requiring the corresponding block in the Cache to be evicted (i. e. , invalidated), this bit is set by a notification message sent from the directory. Therefore, following a miss in the directory, a hit in the LLC where the False Miss Tag is set will immediately identify this as an erroneous miss. Upon detecting a false miss, the LLC controller refuses to satisfy the miss and instead invokes the coherence protocol to issue a broadcast request to locate and use the latest copy of the block. Once the miss is resolved, the coherence protocol registers the block in the directory and resets the corresponding cache bit in the LLC. From this analysis, it is evident that the coherence protocol for the Stash directory undergoes significant changes compared to general protocols and requires specific adjustments during implementation. As seen from the above, the Stash directory requires a shared LLC, which is common in modern Chip Multi-Processors (CMP). The LLC also requires extra bits to store the False Miss Tag. This additional storage is very small (&lt;0. 2% of cache size) and is independent of the number of cores; increasing the core count does not increase the extra storage for False Miss Tags. Conversely, the percentage of extra storage decreases as address length increases. It is also important to note that there must be an inclusion property between the blocks hidden by the directory and the corresponding LLC entries. Fully inclusive LLC designs are common in general multi-core system architectures, so this condition is easily met.  When an LLC block with the “cached” bit set is evicted, copies must be removed from the exclusive Cache hierarchy. Assuming an LLC entry with the cached bit set has no directory information, a background invalidation operation must be broadcast upon eviction. To avoid this, the cache system must implement clean eviction notifications (common in current commercial processors, such as AMD Opteron [5]). Therefore, when a block is evicted from the exclusive Cache hierarchy, a notification is sent to the directory, and the shared LLC is updated to better reflect the block’s sharing state. If the notification finds no corresponding entry in the directory, it implies the block being evicted is a hidden exclusive block currently tracked by the LLC. Thus, the eviction notification is forwarded to the LLC, which clears the cached state bit. Clearing eviction notifications may clear the cached state of LLC blocks before they are evicted, thereby reducing unnecessary broadcasts. Furthermore, allowing the LLC to prioritize replacing entries that have received eviction notifications can delay the eviction of cached LLC blocks. Further techniques to eliminate inclusion side effects can be found in previous studies [6] and are not the focus here. As a conventional sparse directory, the Stash directory handles the eviction of entries tracking shared data blocks by forcing the invalidation of all cached copies. Although this may result in the simultaneous invalidation of blocks across multiple cores, it is preferable. This is because hiding shared blocks (especially migrating ones) significantly increases the frequency of false misses compared to private blocks. Additionally, since the directory is sensitive to the temporal locality of actively shared blocks, victim shared entries (LRU) are likely tracking dead or temporarily exclusive shared blocks, thus benefiting from eviction. In the latter case, eviction gives the shared block a chance to reload as “Exclusive,” and if it remains exclusive, it can re-enter the storage directory. The Stash directory leverages the temporal behavior of actively shared blocks while reducing the pollution of the directory set by truly exclusive items. 4. Feasibility Analysis: 4. 1 Theoretical Feasibility: Regarding the implementation of directory coherence protocols under the Full Directory, Traditional Set-Associative Sparse Directory, Cuckoo Directory, and Stash Directory structures described above, a comparison is made regarding space overhead, hotspot issues, and hardware implementation to establish theoretical feasibility.       Directory Type   Space Overhead   Hotspot Issue   Hardware Complexity         Full Directory   $O(M \times N^2)$   None   Simple       Traditional Sparse Directory   $O(M)$   Severe   Medium       Cuckoo Directory   $O(M)$   Moderate   Relatively Complex       Stash Directory   $O(M)$   Minimal   Complex   4. 2 Experimental Feasibility: The time cost of using hardware circuit connections for simulation experiments is immense; therefore, simple software simulations should be conducted first. gem5 is a computer system architecture simulation platform running on Linux. We configured the gem5 experimental environment on Ubuntu and conducted simple experiments according to the official documentation [7]. gem5 provides two different Cache implementation methods, one of which, the Ruby simulator, allows us to custom configure directory structures, directory implementations, message passing, and coherence protocol details. We simulated a dual-CPU system with distributed storage architecture on gem5, where each CPU includes an L1 Cache, using the MSI directory coherence protocol for simple simulation. The platform can output a series of simulation results, such as total clock cycles based on the execution content. By running test programs with different characteristics and recording data such as total clock cycles and miss rates, we can compare mean values and standard deviations. Based on this more realistic data, we can perform a more complete feasibility verification of the aforementioned schemes.  5. Summary: Addressing the defect of large storage space overhead in traditional directories, we introduced the sparse directory for optimization. Among the various specific types of sparse directories, we first noted the Cuckoo directory, which utilizes hash tables; our research focused primarily on the four-way Cuckoo directory structure. Analysis indicates that under this structure, the time complexity of various operations is low, resulting in high time efficiency. Additionally, the efficiency of the Cuckoo directory depends on the selection of specific hash functions. Considering the principle of program locality and the issue of loop replacement, mapping results in the most scattered scenarios can effectively avoid hotspot issues, thereby achieving optimal performance. Subsequently, we researched the Stash directory, which holds even greater potential. The Stash directory classifies Cache block states into exclusive and shared categories, requiring an additional 1-bit flag in the directory for implementation. When directory replacement occurs, the flag bit determines if an operation is necessary, further improving performance. Finally, future research can further verify the practical effects of these schemes through simulation. From this research, it can be observed that optimizations for computer system structures often adopt methods such as parallelism, scattering, and tagging. These methods either directly or indirectly establish multi-level relationships to achieve buffering, or expand the same level to obtain better parallel operation efficiency. Scattering and similar methods essentially aim to improve the efficiency of parallel processing. These three points can be utilized not only in the optimization of directory coherence protocols but also referenced in the optimization of other processes, achieving broad application. References: [1] Srivatsa Akshay; Fasfous Nael; Anh Vu Doan Nguyen, et al. Exploring a Hybrid Voting-based Eviction Policy for Caches and Sparse Directories on Manycore Architectures[J]. 2021,87(Nov. ):104384. 1-104384. 17 [2] https://web. stanford. edu/class/archive/cs/cs166/cs166. 1146/lectures/13/Small13. pdf [3] Friedhelm Meyer auf der Heide. Algorithms — ESA 2001[M]. Springer, Berlin, Heidelberg, 2001 [4] Wu Jianguo, Chen Haiyan, Liu Sheng, Deng Rangyu, Chen Junjie. A Survey of Performance Improvement Methods for Multi-core Cache Sparse Directories[J]. Computer Engineering &amp; Science, 2019, 41(03):385-392. [5] P. Conway, N. Kalyanasundharam, G. Donley, K. Lepak, and B. Hughes. Cache hierarchy and memory subsystem of the amd opteron processor. IEEE Micro, 2010. [6] A. Jaleel, E. Borch, M. Bhandaru, S. C. Steely Jr. , and J. Emer. Achieving non-inclusive cache performance with inclusive caches: Temporal locality aware (tla) cache management policies. MICRO, 2010. [7] https://www. gem5. org/documentation/learning_gem5/introduction/ "
    }, {
    "id": 16,
    "url": "http://localhost:4000/Cache/",
    "title": "多核体系下Cache目录一致性协议优化方案",
    "body": "2025/12/16 - 在多核系统结构下，Cache一致性协议有监听协议和目录协议两种，其中后者是更优的。在经典的目录中，每一个数据块都有对应的目录项，这使得存储的空间开销很大。故而可以使用稀疏目录，通过只维护被Cache缓存的数据对应的信息来减少开销。稀疏目录中的Cuckoo目录是一种较好的方案，它使用哈希表的方式对稀疏目录进行改进。一种潜力更好的目录是Stash目录，它在目录中增加了一个标记位来区分Cache的状态，进一步减小了性能损失。以上两种稀疏目录方案对传统目录的优化是明显的。基于理论分析，还可以通过仿真模拟验证其实际可行性。 1. 引言: 随着计算机系统的发展，多核和众核体系结构已经成为实现高性能和并行计算的重要手段。在多核体系结构中，Cache作为一个关键的组件，起到了提升数据访问速度和提高系统性能的作用。然而，多个核之间私有缓存的读写可能存在不一致问题，因此诞生了许多一致性协议来解决这一棘手难题，其中可扩展性较好的一种协议是目录一致性协议。但随着核心数量的增加和共享数据的增多，传统的基于目录的Cache一致性方案面临着目录的存储和访问开销过大的问题。本文基于分布式存储下的同构多核体系结构，分析了已有的稀疏目录方案及其对传统的基于目录Cache一致性方案的优化效果，并在此基础上提出进一步优化方法。 本文首先简单介绍分布式存储下同构多核体系结构使用的目录一致性协议基本原理，然后阐述现有的对目录结构优化为稀疏目录的方案，并提出全新的优化结果，最后分析各方案的优缺点和可行性。 2. 分布式存储下的目录一致性协议: 目录一致性协议是对监听协议的改进方案，它引入的目录这一数据结构使得系统的扩放性更好。目录中存放的各数据块的相关信息使得访问操作的效率更高，且避免了监听协议中广播机制对系统性能的限制。在分布式共享存储器系统中使用经典的目录一致性协议时，每个数据块都在目录中有存放相关数据的一项，基于这点，我们将其称为完整目录以方便后续讨论。 下面我们简单对完整目录的开销进行分析。这种目录中，每个节点都维护了一个完整的目录信息。设每个节点的存储器中有M个块，一共有N个节点，则每个完整目录中需要记录$M \times N$个目录项，整个系统在目录的空间开销上就达到了$O(M \times N \times N)$数量级。由于处理器数量较多，目录项本身的存储开销是很大的，当节点数量N增多时，空间开销将以平方数量级增长，系统的扩放性很差。同时，因此我们可以考虑减少每个节点中目录的条数来缩减完整目录的开销。于是我们引入了稀疏目录作为改进方案。 3. 稀疏目录: 3. 1 稀疏目录: 稀疏目录定义最早在1992年提出，它与完全目录的区别是：目录项分配方式不同。前者为所有的末级缓存LLC（Last Level Cache）的Cache块分配的一个目录项，记录对应Cache块状态信息。由于某一时间点只有一小部分块被调入各Cache成为私有缓存，大部分目录短期内不会被访问，尤其当核数增多、存储空间增大时这些目录占比会越来越大，因此应当减少这些目录的存储开销。稀疏目录只维护被私有Cache缓存的数据所对应的一致性信息，每个目录项包括tag位（索引Cache块地址）、状态位（记录对应Cache块一致性状态）、共享列表（记录数据副本在各处理器核分布情况）[1]。 稀疏目录具有低相连度和大目录容量的特点。相连度较低的目的是减小目录查找功耗，但会增加组冲突概率、增加目录项替换次数。目录替换又会导致对应Cache块无效，导致共享这一Cache块的节点都需要进行替换，增加访问延迟，造成数据抖动，从而降低系统性能。为减小目录冲突频率和避免性能损失，采用过量供应的目录容量，通过增加目录组数减小组内访问冲突。 3. 2 Cuckoo目录及其实现: Ferdman等人提出用Cuckoo目录来减少稀疏目录面临的冲突替换，用以解决传统方案中组冲突带来的强制无效和Cache抖动问题。这种方案既保留了稀疏目录减小存储开销的优势，又很大限度的保持各节点Cache的稳定，是一种相对理想的稀疏目录方案。 Cuckoo目录的实现基于Cuckoo Hashing。最简单的稀疏目录采用组相联的方式来减少目录项，其本质是一种散列，因此使用哈希表的方式改进稀疏目录是可行的。Cuckoo Hashing又名链式哈希，它拥有并行的两个以上的哈希表，来减小发生哈希冲突时的开销。由于稀疏目录在减少开销以后面临的主要问题是组相联目录中的冲突问题，因此用链式哈希来减小冲突是更优的。具体实现时，可以采用四路Cuckoo目录结构，对每一路使用不同的哈希函数进行散列。当有新的块变为私有存储需要添加到目录中时，会产生插入操作，操作如下：  计算各路哈希函数结果。 如果映射的位置是空的，则插入到该位置（有多个路有空位置时可以任选一个插入）。 如果映射的位置都不空，则从第一路开始选择有空位置的路插入，将原来的目录项移出。 重新计算被移出的目录项的各路哈希函数结果，如果映射的位置是空的，则执行②，否则执行③。 如果重复进行③④的操作而无法跳出循环，在达到一定次数后不再重新映射，直接强制踢出该目录项，由于这样也相当于作废了Cache中的一个块，对运行效率是有一定负面影响的。 查询目录内容时，只需将待查询的块索引进行四路哈希映射，再到对应位置匹配索引即可获知是否命中。显然，查询的时间复杂度为$O(1)$，但插入的操作时间取决于循环替换的次数，用摊还时间分析得到插入的摊还时间也是$O(1)$[2]，Cuckoo目录具有较好的时间效率。 在此采用Cuckoo哈希而不是普通的哈希表有许多原因。其一，如果采用一般的哈希表，解决冲突时最快的方法是线性探测，实践证明线性探测比Cuckoo哈希快16%-23%[3]，但由于Cuckoo哈希的各操作摊还代价都是$O(1)$，所以在快速响应上并不比线性探测慢。其二，线性探测容易导致目录项集中在某个区域，容易产生热点问题，Cuckoo哈希的四路结构则更普遍地将各目录项均匀分布并分布在不同路上，是更适合应用在计算机系统结构设计上的哈希数据结构。 所以，哈希函数的选取很大程度上决定了最终实现的效率，四个哈希函数的选取必须保证有很好的散列性质，映射的结果要均匀。同时，由于局部性原理，节点在一段时间内查询的块地址是比较连续的，散列的结果应该能够将连续地址映射同一路中相隔较远的项上，这样才能避免热点问题。 还需要考虑循环替换时应当尽可能地减少循环次数，因此四路哈希的映射结果最好具有一定的区别。设地址空间从0到N，每路目录项为N/10，经过我们的分析，设计了一种函数映射方式，图2是该设计对0-N/10地址空间的映射结果示例。根据局部性原理和私有缓存占总存储的比例，某一时刻在目录中记录的块号一般集中在N/10大小的较连续区域内，此时斜率为1的映射方式用不同的偏移量使得每个块都有四个分散的不同哈希结果，在任意时刻都尽可能地使用了更分散的目录项，最大化减少热点问题。 3. 3 Stash目录: Cuckoo目录用多个不同的哈希函数成功减少了冲突和热点问题，但插入到强制结束状态时会踢出最后一块，这本质上是没有利用局部性原理的，所以并不能完全避免数据抖动，因此Demetriades等人提出了Stash目录[4]。 考察一个处于独占状态的Cache块，在其它节点需要调用它前，对该块进行读写操作是不需要受到限制的。Stash目录利用了这一特性，将被缓存的Cache块分为”独占”和”共享”两种不同的状态，并在目录中增加1位标记来进行区分。一般情况下，我们用0表示”独占”，1表示”共享”。从硬件层面考虑，因为每当有新的目录项加入时，一定是独占状态，存储器的初始状态一般是0，因此不需要额外操作就可以记录好这一位，这样的0-1对应是合理的。 考虑目录某一项发生替换的情况，如果此时根据标记判断出该块是”独占”状态，就不把这一块从Cache中真正踢出，因为独占它的节点无论如何读写它都不会产生一致性问题，直到有别的节点要调用这一块。当别的节点调用这一块时，由于目录中对该块的记录已经不存在，所以会误认为该块没有在任何节点的私有缓存中，这被称为假缺失（False Miss）。 为了避免假缺失，需要在共享LLC中为每个Cache块增加1位标记位来表明相应Cache块是否已被更低级Cache缓存，这样我们就有了新的方法来进一步确定每个块的真实状态。 Stash目录利用共享LLC和一致性协议检测假缺失等问题。共享LLC中已经为每个缓存块保留了一个假缺失Tag位，来指示该块是否可能在层次结构的较低级别中”缓存”。每当目录项被踢出而不需要使Cache中相应块也被踢出（即无效）时，该位由目录发送的通知消息设置。因此，目录中的未命中之后，LLC中设置了假缺失Tag位的命中将立即判断出这是错误的未命中。检测到错误的未命中时，LLC控制器将拒绝满足未命中，而是调用一致性协议发出广播请求，以把块的最新副本找出使用。未命中完成后，一致性协议将在目录中注册块，并重置LLC中相应的缓存位。由此分析可知，Stash目录的一致性协议与一般的协议有较大的变化，实现时需要单独做出调整。 从上述内容可以看出，Stash目录需要共享LLC，这在现代CMP中是常见的。LLC中还需要额外的位来存储假缺失Tag，这份额外存储非常小（&lt;缓存大小的0. 2%），而且与内核数量无关，无论核数增长多少也不会导致假缺失Tag的额外存储增加，反而会因为地址长度增加而减少额外存储的占比。显然还需要注意，被目录隐藏的块和相应的LLC条目之间必须是包含属性，完全包含的LLC设计也是一般常见的多核系统架构，所以这一条件很容易被满足。 当具有”缓存”位集的LLC块被逐出时，必须从独占Cache层次结构中删除副本。假定具有缓存位集的LLC条目没有目录信息，则必须广播逐出的后台无效操作。为了避免这种情况，缓存系统必须实现干净的逐出通知（在当前的商业处理器中很常见，例如AMD Opteron[5]）。因此，当从独占Cache层次结构逐出块时，发送通知到目录并更新共享LLC，以更好地反映块的共享状态。 如果通知在目录中找不到相应的条目，则意味着要逐出的块是隐藏的独占块，并且当前由LLC跟踪。因此，逐出通知将转发给LLC，并且它将清除缓存状态位。清除逐出通知可能会在LLC块被逐出之前清除它们的缓存状态，从而减少不必要的广播。此外，允许LLC首先替换接收到逐出通知的条目，可以延迟缓存的LLC块被逐出。消除包容性副作用的进一步技术可在先前的研究中找到[6]，此处不是研究重点就不再详述。 作为一个常规的稀疏目录，Stash目录处理跟踪共享数据块的条目的逐出，它强制所有缓存副本失效。尽管这可能会导致多个核心中的块同时失效，但这是优选的，因为与私有块相比，隐藏共享块（特别是迁移）可能会显著增加错误命中的频率。 此外，由于目录对主动共享的块的时间位置敏感，受害共享条目（LRU）很可能跟踪死的或暂时独占的共享块，因此从逐出中受益。在后一种情况下，逐出将使共享块有机会重新加载为”独占”，并且如果要保持独占，则可以重新进入存储目录。Stash目录利用了主动共享块的时间行为，同时减少了真正独占项对目录集的污染。 4. 可行性分析: 4. 1 理论可行性: 针对以上阐述的完整目录、传统组相联稀疏目录、Cuckoo目录和Stash目录结构下的目录一致性协议实现，从空间开销、热点问题、硬件实现等方面做出比较，并得到理论上的可行性。       目录类型   空间开销   热点问题   硬件实现复杂度         完整目录   $O(M \times N^2)$   无   简单       传统稀疏目录   $O(M)$   严重   中等       Cuckoo目录   $O(M)$   较轻   较复杂       Stash目录   $O(M)$   最轻   复杂   4. 2 实验可行性: 使用硬件电路连接来进行模拟实验的时间成本是巨大的，应当先对以上方案进行简单的仿真模拟。gem5是在Linux系统上运行的一个计算机系统结构仿真实验平台，我们在Ubuntu上配置了gem5的实验环境，并根据官方文档进行了简单的实验[7]。gem5提供了两种不同的Cache实现方式，其中一种Ruby模拟器可以让我们自行设置目录结构、目录实现、消息传递以及一致性协议的不同细节。我们在gem5上进行了一个分布式存储体系的双CPU系统，每个CPU包含L1 Cache，使用MSI目录一致性协议进行简单的模拟，平台可以给出基于运行内容的总时钟周期等一系列模拟结果。我们可以通过运行不同特点的测试程序并记录它们的总时钟周期数、不命中率等数据，用平均值与标准差进行比较。基于这些更为真实的数据，我们可以对上述方案进行更加完备的可行性验证。 5. 总结: 基于传统目录存储空间开销大的缺陷，我们引入了稀疏目录对其进行优化。在稀疏目录的多种具体类型中，我们首先注意到Cuckoo目录，它采用的是哈希表，我们主要对四路Cuckoo目录结构进行了研究。分析得出，此种结构下各操作时间复杂度都较低，其时间效率较高。另外，Cuckoo目录的效率还取决于具体哈希函数的选取。考虑到程序的局部性原理和循环替换的问题，映射的结果在最分散的情况下可以较好的避免热点问题，从而获得最佳的性能。随后，我们又对潜力更好的Stash目录进行研究。Stash目录将Cache块的状态分为独占与共享两类，这需要在目录中增加1位标记位来实现。在目录发生替换时，可以通过标记位来判断是否需要进行操作，这进一步提高了性能。最后，在今后的研究中可以通过仿真模拟对这些方案的实际效果进行进一步验证。 从研究中可以发现，对计算机系统结构的优化往往是采用并行、分散、标记等方式，它们要么直接或间接地建立了多级关系来达到缓冲这一目标，要么把同一级展开获得更好地并行操作提高效率，而分散等方式本质上还是在提高并行处理的效率。不仅在目录一致性协议的优化中可以使用这三点，在其它过程的优化中也可以参考这些常用而非常有效的方法，达到举一反三的效果。 参考文献: [1] Srivatsa Akshay; Fasfous Nael; Anh Vu Doan Nguyen, et al. Exploring a Hybrid Voting-based Eviction Policy for Caches and Sparse Directories on Manycore Architectures[J]. 2021,87(Nov. ):104384. 1-104384. 17 [2] https://web. stanford. edu/class/archive/cs/cs166/cs166. 1146/lectures/13/Small13. pdf [3] Friedhelm Meyer auf der Heide. Algorithms — ESA 2001[M]. Springer, Berlin, Heidelberg, 2001 [4] 吴健虢,陈海燕,刘胜,邓让钰,陈俊杰. 多核Cache稀疏目录性能提升方法综述[J]. 计算机工程与科学,2019,41(03):385-392. [5] P. Conway, N. Kalyanasundharam, G. Donley, K. Lepak, and B. Hughes. Cache hierarchy and memory subsystem of the amd opteron processor. IEEE Micro, 2010. [6] A. Jaleel, E. Borch, M. Bhandaru, S. C. Steely Jr. , and J. Emer. Achieving non-inclusive cache performance with inclusive caches: Temporal locality aware (tla) cache management policies. MICRO, 2010. [7] https://www. gem5. org/documentation/learning_gem5/introduction/ "
    }, {
    "id": 17,
    "url": "http://localhost:4000/LeetCode1219-en/",
    "title": "A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold",
    "body": "2025/12/15 - Algorithm Approach: A 2D vector is used to store the distribution of the gold mines. The algorithm first traverses the entire grid. Any coordinate with a non-zero value is treated as a starting point. We employ DFS (Depth-First Search) with backtracking to search the entire graph. During the search process, visited coordinates are marked (by setting the gold amount to 0), while tracking the currently accumulated gold. The class maintains a max variable to record the maximum gold collected and a path variable to store the optimal path. Whenever a path yielding more gold is found, both max and path are updated simultaneously. During backtracking, the stack recording the current path is popped once, and the visited marker is released. Consequently, the path with the maximum gold and the total amount can be determined. Complexity Analysis: Since the search result depends on the traversal of areas containing gold, let \(k\)be the total number of cells with gold. Let\(m\)be the number of rows and\(n\)be the number of columns. Obviously,\(k \le mn\). Therefore, any subsequent operations involving \(\min\{mn, k\}\)can be simplified directly to\(k\). The algorithm uses two stacks to store the path; thus, the space complexity is \(O(k+k)\), which simplifies to \(O(k)\). Let us define a forward exploration step as the basic operation. Each cell with gold can serve as a starting point for DFS traversal, resulting in a total of \(k\)traversals. In each traversal, apart from the starting point, every cell has at most three different directions to proceed. Therefore, the exploration operations scale with at least\(3k\). It follows that the worst-case time complexity is \(O(3^k)\). However, upon testing with map data where \(k=25\), the execution efficiency was surprisingly high. It did not exhibit the inefficiency expected from a base-3 exponential function. This suggests that the estimated upper bound of “\(3^k\) total exploration operations per starting point” is overly loose. Since exploration operations only occur in cells containing gold, we analyze them separately. For any collection path, excluding the start and end cells, the intermediate cells are traversed in one of the following seven patterns:  Left-in Up-out or Up-in Left-out — abbreviated as LU Right-in Up-out or Up-in Right-out — abbreviated as RU Also LD, RD, LR, UD Not traversed by the path, noted as NThus, the solution space tree, originally constructed by three exploration directions per cell, is transformed into one based on the traversal patterns of each cell. Next, we divide all cells containing gold (excluding the start and end points) into a staggered black-and-white pattern as follows: (For convenience, assume they are clustered in a \(3 \times 3\) grid).  From the seven patterns mentioned above, we know that if the state of every black cell is determined, the state of the white cells is implicitly determined. Therefore, we only need to consider the black cells. Clearly, this partition results in approximately \(k/2\) black cells. When generating the solution space tree, before traversing the 7 possibilities for cell B, the states of the four surrounding black cells have already been determined (excluding start/end points, which does not affect the complexity analysis). In the figure, if we assume A is determined as LR, then B is restricted to only four cases: LU, RU, UD, or N. The same logic applies elsewhere. Consequently, when generating the solution space tree, each black cell effectively has only 4 exploration choices for the next step. The worst-case time complexity does not exceed \(O(4^{k/2}) = O(2^k)\). In practice, since gold cells are not always clustered together, the available choices for each black cell will likely be fewer than 4, resulting in even lower time complexity. In summary, the worst-case time complexity does not exceed \(O(2^k)\). I encountered this problem during an algorithm course assignment. I felt the online time complexity analysis differed from my practical experience, so I made some improvements here. "
    }, {
    "id": 18,
    "url": "http://localhost:4000/Elevator/",
    "title": "电梯调度 - TJU操作系统课设方案",
    "body": "2025/12/15 - 开发环境:  开发环境：Windows 11 开发软件：Visual Studio 2022 开发语言：C# 主要引用模块：System, System. Threading实现的功能:  互联接的上下行按钮：当按下五部电梯门口的上下行按钮时，五部电梯都收到这个请求，根据调度算法决定具体由哪部电梯响应这个请求。 独立的楼层按钮：每部电梯都有各自的楼层按钮，当按下电梯内部的楼层按钮时，该请求由这部电梯响应，具体何时响应由调度算法决定。 添加乘客功能：支持添加乘客，需指定乘客起始楼层和目标楼层，调度算法决定由哪部电梯响应乘客的请求。 数码管显示电梯当前楼层：每部电梯都有一个数码管显示其当前所在楼层。 电梯状态显示：每部电梯都有一个标签显示电梯当前状态：有 up，down，wait，alarm 四种状态。 电梯容量显示：每部电梯都有一个标签显示电梯可用容量，初始为 5。 开门、关门键：当电梯到达乘客所在楼层和目标楼层时，需要完成开门和关门操作。 提示信息框：在特定时候弹出提示信息，显示乘客被分配到了哪部电梯以及提示用户进行开门或关门操作。 乘客状态表：根据乘客状态实时更新乘客当前所在楼层，只显示未到达目标楼层的乘客。界面: 操作指南:  用户可以随意点击数字键和上行下行键让电梯在没有乘客的情况下“空跑”，便于观察电梯调度算法的实际表现。 用户也可以在右侧的乘客管理模块添加乘客，设定乘客的起始楼层和目标楼层，观察乘客被分配到哪个电梯中，以及乘客乘上电梯时的实际楼层变化，当乘客到达目标楼层时，乘客将从表格中移除。 下方的状态栏显示提示信息，提示用户在必要时刻进行开门和关门操作。 乘客可以点击 “Open” 和 “Close” 键让电梯开门和关门，也可以按下 “Alarm” 键让电梯处于报警状态。 电梯所在楼层和剩余容量在每部电梯上方显示，电梯的当前状态在每部电梯下方显示。主要设计思路: 实现的类:  Form1类：程序的主窗口，负责UI的显示与更新，处理UI的点击事件，管理与乘客有关的逻辑、订阅 ElevatorController 中定义的事件。 ElevatorController类：实现了电梯的调度算法，管理电梯列表，定义了一些关键的事件。 Elevator类：记录电梯的属性，包括电梯的当前楼层，目标楼层，电梯的状态，电梯的容量，提供了一些公用的方法，可以对电梯的这些属性进行设置和获取。 Passenger类：记录每个乘客的ID，当前所在楼层和目标楼层，被分配到的电梯，以及请求是否已被处理。Elevator 类: 电梯的实体，记录每部电梯的状态（等待，上行，下行，报警），当前所在楼层和目标楼层，定义了一些必要的方法，用于得到或设置电梯内的一些成员变量： namespace ElevatorSystem{  public enum status  {    wait, up, down, alarm  };  public class Elevator  {    status currentStatus;    int currentFloor;    int targetFloor;    int capacity;    public Elevator(int current=0,int target=0)    {       currentFloor = current;      targetFloor = target;      capacity = 5;      currentStatus = status. wait;    }    public int getCurrentFloor() { return currentFloor; }    public int getTargetFloor() { return targetFloor;}    public int getCapacity() { return capacity;}    public void takePassenger() { capacity--; }    public void ariveTargetFloor() { capacity++; }    public void setTargetFloor(int target) { targetFloor = target; }    public void setStatus(status sta) { currentStatus = sta; }    public status getStatus() { return currentStatus; }    public void up()    {       currentStatus = status. up;      if (currentFloor &lt; 20)      {        currentFloor++;        Thread. Sleep(500);      }    }    public void down()    {      currentStatus = status. down;      if (currentFloor &gt; 0)      {        currentFloor--;        Thread. Sleep(500);      }    }    public void move()    {      if (currentFloor &lt; targetFloor) up();      if (currentFloor &gt; targetFloor) down();    }    public bool check()    {      if (capacity &lt; 0)      {        currentStatus = status. alarm;        return false;      }      return true;    }  }}Passenger 类: 乘客的实体，记录每个乘客的ID，当前所在楼层和目标楼层，被分配到的电梯，以及请求是否已被响应： namespace ElevatorSystem{  public class Passenger  {    public int id { get; set; }    public int currentFloor { get; set; }    public int targetFloor { get; set; }    public int assignedElevator { get; set; } // 假设电梯分配后存储电梯的编号    public bool isHandled { get; set; } = false; // 默认为false，表示未处理    public Passenger(int ID, int current, int target, int assigned)    {      id = ID;      currentFloor = current;      targetFloor = target;      assignedElevator = assigned;    }  }}类之间的联系: 通过在 Form1 中引入 ElevatorController 的示例 manage，实现两个类的交互，在 Form1 的初始化函数中完成对在 ElevatorController 中定义的事件的订阅： public Form1(){  InitializeComponent();  InitializeElevatorUI();  InitialMassageBox();  InitializeFloorRequestButtons();  InitializePassengerManagementUI();  manage = new ElevatorController();    // 事件订阅  manage. ElevatorMoved += Manage_ElevatorMoved;  manage. ElevatorRequestProcessed += Manage_ElevatorRequestProcessed;  manage. ElevatorExternalRequestProcessed += Manage_ExternalRequestProcessed;  manage. OpenDoorPressed += Manage_OpenDoorPressed;  manage. CloseDoorPressed += Manage_CloseDoorPressed;   LoadImages();  InitializeTimer();} 在Form1中定义Passenger类型的列表passengers，实现对乘客的管理； 在ElevatorController中定义Elevator类型的数组elevators，实现对五部电梯的管理；调度算法:  在ElevatorController中定义四个二维数组，记录需要处理的上行和下行请求，以及等待处理的上行和下行请求：  public int[,] upRequest = new int[ElevatorsCount, FloorsCount];public int[,] downRequest = new int[ElevatorsCount, FloorsCount];//wait数组里储存的是电梯需要经过状态变换才能处理的请求public int[,] waitUpRequest = new int[ElevatorsCount,FloorsCount];public int[,] waitDownRequest = new int[ElevatorsCount, FloorsCount];      wait数组里储存的时电梯需要经过状态变换才能处理请求；     当上行键被按下时，调用public int handleUpRequest(int floor)，处理上行请求；当下行键被按下时，调用public int handleDownRequest(int floor) ，处理下行请求；两个函数的返回值都是被分配到的电梯编号；具体来说，调度算法如下（以处理上行请求为例）：     根据每部电梯的状态和电梯所在楼层计算与被按下的上行键所在楼层的距离：          如果电梯处于静止状态，这个距离等于电梯所在楼层减去上行键所在楼层的绝对值；           如果电梯处于上行状态，那么分为两种情况：          电梯当前所在楼层大于上行键所在楼层，这个距离等于该电梯目前向上请求中最高的层减去电梯所在楼层的绝对值，加上电梯目前向上请求中最高的层减去上行键所在楼层的绝对值；     电梯当前所在楼层小于上行键所在楼层，这个距离等于电梯当前所在楼层减去上行键所在楼层的绝对值；              如果电梯处于下行状态，那么这个距离等于该电梯目前向下请求中的最低的层减去电梯所在楼层的绝对值，加上电梯目前向下请求中最低的层减去上行键所在楼层的绝对值；        选出与上行键所在楼层距离最近的电梯，并在其上行请求列表中添加上行键所在的楼层：     如果该电梯目前处于静止状态，那么有两种情况：         上行键所在楼层大于电梯所在楼层，把该请求添加进upRequest[elevatorIndex,floor]中，因为电梯即将改变成上行状态，该请求能立即得到处理；     上行键所在楼层小于电梯所在楼层，把该请求添加进waitUpRequest[elevatorIndex,floor]中，因为电梯需要先改变成下行状态，再改变成上行状态，才能处理该请求；          如果电梯目前处于上行状态，那么有两种情况：         上行键所在楼层大于电梯所在楼层，把该请求添加进upRequest[elevatorIndex,floor]中，因为电梯不需要改变状态就可以响应该请求；     上行键所在楼层小于电梯所在楼层，把该请求添加进waitUpRequest[elevatorIndex,floor]中，因为该电梯需要改变状态才能响应该请求；              如果电梯处于下行状态，那么直接把请求添加进waitUpRequest[elevator,Index]中，因为该电梯需要改变状态才能响应该请求。```csharppublic int handleUpRequest(int floor){int minDist = FloorsCount + 1;int elevatorIndex = ElevatorsCount;     for(int i=0;i&lt;ElevatorsCount;i++){  int currentFloor = elevators[i]. getCurrentFloor();  if (elevators[i]. getStatus()==status. alarm)  {    continue;  }  if (elevators[i]. getStatus()==status. wait)  {    if(Math. Abs(currentFloor-floor) &lt; minDist)    {      minDist=Math. Abs(currentFloor-floor);      elevatorIndex=i;    }  }  else if (elevators[i]. getStatus()==status. up)  {    if(currentFloor &lt;= floor)    {      if(Math. Abs(currentFloor-floor)&lt;minDist)      {         minDist = Math. Abs(currentFloor-floor);        elevatorIndex = i;       }    }    else if(currentFloor &gt; floor)    {      int tmp = 0;      //找到目前向上请求中最高的楼层      for(int j=FloorsCount-1;j&gt;=0;j–)      {        if (upRequest[i, j] == 1)        {          tmp = j;          break;        }      }      //计算距离      int dist = Math. Abs(tmp - currentFloor) + Math. Abs(tmp - floor);      if(dist&lt;minDist)      {        minDist=dist;        elevatorIndex = i;      }    }     }else if (elevators[i]. getStatus()==status. down){  int tmp = 0;  //找到目前向下请求中最小的层  for(int j=0;j&lt;FloorsCount;j++)  {    if (downRequest[i, j] == 1)    {      tmp = j;      break;    }  }  int dist=Math. Abs(tmp - currentFloor) + Math. Abs(tmp - floor);  if(dist&lt;minDist)   {    minDist=dist;    elevatorIndex = i;  } } } int currenFloor = elevators[elevatorIndex]. getCurrentFloor(); if (elevators[elevatorIndex]. getStatus()==status. wait) {   if(floor &gt;= currenFloor)  upRequest[elevatorIndex, floor] = 1;else  waitUpRequest[elevatorIndex, floor] = 1;   //upRequest[elevatorIndex, floor] = 1; } else if (elevators[elevatorIndex]. getStatus()==status. up)        {  if (floor &gt;= currenFloor)    upRequest[elevatorIndex, floor] = 1;  else    waitUpRequest[elevatorIndex, floor] = 1;}else  waitUpRequest[elevatorIndex,floor] = 1;     return elevatorIndex;}          当楼层按钮被按下时，直接对upRequest和downRequest进行修改，当在上行电梯中按下比电梯当前所在楼层小的楼层，将不会被响应，当在下行电梯中按下比电梯当前所在楼层小的楼层，将不会被响应：   private void FloorButton_Click(object sender, EventArgs e, int elevatorIndex, int floor) {    Button clickButton = sender as Button;      // 处理楼层按钮点击事件   //MessageBox. Show($ 电梯 {elevatorIndex + 1} 的第 {floor + 1} 层按钮被点击 );   if (manage. elevators[elevatorIndex]. getStatus()==status. up)   {     if (floor &gt;= manage. elevators[elevatorIndex]. getCurrentFloor())     {       manage. upRequest[elevatorIndex, floor] = 1;       if (clickButton != null)       {         clickButton. BackColor = Color. Green;       }      }   }   else if (manage. elevators[elevatorIndex]. getStatus()==status. down)   {     if (floor &lt;= manage. elevators[elevatorIndex]. getCurrentFloor())     {       manage. downRequest[elevatorIndex, floor] = 1;       if (clickButton != null)       {         clickButton. BackColor = Color. Green;       }      }   }   else   {     if (floor &gt;= manage. elevators[elevatorIndex]. getCurrentFloor())     {       manage. upRequest[elevatorIndex, floor] = 1;       if (clickButton != null)       {         clickButton. BackColor = Color. Green;       }      }     else     {       manage. downRequest[elevatorIndex,floor] = 1;       if (clickButton != null)       {         clickButton. BackColor = Color. Green;       }      }   } }    电梯运行逻辑:   为每部电梯启动一个独立的线程，并设置线程为后台线程，线程执行private void ElevatorRoutine(int elevatorIndex) 方法：```csharpprivate void StartElevatorThreads(){ for(int i=0;i&lt;ElevatorsCount;i++) {   int index = i;   Thread elevatorThread = new Thread(() =&gt; ElevatorRoutine(index))   {     IsBackground = true   };   elevatorThread. Start(); }}private void ElevatorRoutine(int elevatorIndex) {  while (true)  {   Thread. Sleep(500);  pullUpward(elevatorIndex);  Thread. Sleep(500);  prepareForDown(elevatorIndex);  Thread. Sleep(500);  pushDownward(elevatorIndex);  Thread. Sleep(500);  prepareForUp(elevatorIndex);} } ``` - 在void pullUpward(int elevatorIndex)里处理电梯的上行请求，在void pushDownward(int elevatorIndex)里处理电梯的下行请求； - 对waitUpRequest和waitDownRequest的处理分别在prepareForUp和prepareForDown中进行； - 在ElevatorController的初始化函数中启动线程： ```csharp public ElevatorController() {for(int i=0;i&lt;elevators. Length; i++) {  elevators[i] = new Elevator();}for(int i=0;i &lt; ElevatorsCount;i++){  for(int j=0;j &lt; FloorsCount;j++)  {    upRequest[i, j] = 0;    downRequest[i, j] = 0;    waitUpRequest[i, j] = 0;    waitDownRequest[i, j] = 0;  }}StartElevatorThreads(); } ``` ### 事件定义 - 在ElevatorController中定义了五个事件： ```csharp public event Action&lt;int, int&gt; ElevatorMoved; public event Action&lt;int, int&gt; ElevatorRequestProcessed; public event Action&lt;int, int&gt; ElevatorExternalRequestProcessed; public event Action&lt;int&gt; OpenDoorPressed; public event Action&lt;int&gt; CloseDoorPressed; ``` 分别用于处理电梯移动，电梯楼层请求被处理和电梯外部请求被处理，开门按钮被按下和关门按钮被按下； - 在Form1中订阅这些事件： ```csharp manage. ElevatorMoved += Manage_ElevatorMoved; manage. ElevatorRequestProcessed += Manage_ElevatorRequestProcessed; manage. ElevatorExternalRequestProcessed += Manage_ExternalRequestProcessed; manage. OpenDoorPressed += Manage_OpenDoorPressed; manage. CloseDoorPressed += Manage_CloseDoorPressed; ``` - 事件订阅是一个在软件设计中常见的模式，它属于更广泛的发布-订阅（pub-sub）模式。在这种模式中，组件可以宣布（发布）某些事件的发生，而其他组件可以表达对这些事件的兴趣（订阅），当事件发生时，这些订阅了事件的组件会自动接收通知并作出相应的响应。 - 例如，在ElevatorController的pullUpward方法中，执行下面这个片段，程序会检验电梯当前所在楼层是否存在请求，如果有，则请求被响应，事件被触发，接着订阅了事件的方法将会被调用，楼层按钮和上行按钮的高亮会消失，电梯也能得到位置的更新： ```csharp while (elevators[elevatorIndex]. getCurrentFloor() != elevators[elevatorIndex]. getTargetFloor()) {elevators[elevatorIndex]. move();if (upRequest[elevatorIndex, elevators[elevatorIndex]. getCurrentFloor()] == 1){  upRequest[elevatorIndex, elevators[elevatorIndex]. getCurrentFloor()] = 0;  ElevatorRequestProcessed. Invoke(elevatorIndex, elevators[elevatorIndex]. getCurrentFloor());  ElevatorExternalRequestProcessed. Invoke(elevators[elevatorIndex]. getCurrentFloor(), 1);}ElevatorMoved. Invoke(elevatorIndex, elevators[elevatorIndex]. getCurrentFloor()); } if (elevators[elevatorIndex]. getCurrentFloor() == i) {upRequest[elevatorIndex, i] = 0;ElevatorRequestProcessed. Invoke(elevatorIndex, i);ElevatorExternalRequestProcessed. Invoke(i, 1); } ``` ### 定义计时器 - 定时器（Timer）在编程中用于在设定的时间间隔内重复执行某些任务，或者在一定的延迟之后执行任务。checkElevatorTimer. Elapsed += CheckElevatorStatus; 这行代码表示将 CheckElevatorStatus 方法绑定到定时器的 Elapsed 事件。这意味着每当定时器的计时周期结束时，CheckElevatorStatus 方法将被自动调用。AutoReset = true 设置定时器在触发 Elapsed 事件后自动重新开始计时。这使得定时器成为一个重复触发的周期性定时器。 - 项目中一共使用了三个定时器，分别用于播放动画，检查电梯状态，以及更新乘客列表： ```csharp private void InitializeTimer() {animationTimer. Interval = 200; // 设置动画帧切换的时间间隔为200毫秒animationTimer. Tick += new EventHandler(AnimationTimer_Tick);updateTimer = new System. Windows. Forms. Timer();updateTimer. Interval = 1000; // 更新间隔设置为1000毫秒（1秒）updateTimer. Tick += new EventHandler(UpdateTimer_Tick);updateTimer. Start();// 初始化定时器checkElevatorTimer = new System. Timers. Timer(1000); // 设置时间间隔为1秒checkElevatorTimer. Elapsed += CheckElevatorStatus;checkElevatorTimer. AutoReset = true;checkElevatorTimer. Enabled = true; // 初始状态为禁用 } ``` - `CheckElevatorStatus`定时检查是否有电梯到达了乘客的目标楼层，并更新电梯的状态标签： ```csharp private async void CheckElevatorStatus(Object source, System. Timers. ElapsedEventArgs e) {// 在Task. Run内执行需要在UI线程上完成的操作await Task. Run(() =&gt;{  Invoke((MethodInvoker)delegate  {    foreach (var passenger in passengers)    {      if (!passenger. isHandled &amp;&amp; manage. elevators[passenger. assignedElevator]. getCurrentFloor() == passenger. currentFloor)      {        passenger. isHandled = true;        messageBox. AppendText($ Please press the open door button for Elevator {passenger. assignedElevator + 1} to let the passenger in. {Environment. NewLine} );        var openTcs = new TaskCompletionSource&lt;bool&gt;();        openDoorTcs[passenger. assignedElevator] = openTcs;        openTcs. Task. ContinueWith(async t =&gt;        {          // 等待两秒后，执行后续逻辑          await Task. Delay(2000);          openDoorButtons[passenger. assignedElevator]. BackColor = Color. White;          var closeTcs = new TaskCompletionSource&lt;bool&gt;();          closeDoorTcs[passenger. assignedElevator] = closeTcs;          await closeTcs. Task;          // 关门后延迟两秒          await Task. Delay(2000);          closeDoorButtons[passenger. assignedElevator]. BackColor = Color. White;          Invoke((MethodInvoker)(() =&gt; toTargetFloorOfPassenger(passenger. id, passenger. assignedElevator, passenger. targetFloor)));        }, TaskScheduler. FromCurrentSynchronizationContext());      }    }  });});// 其他状态更新也必须在UI线程上执行Invoke((MethodInvoker)delegate{  for (int i = 0; i &lt; ElevatorsCount; i++)  {    Elevator elevator = manage. elevators[i];    status currentStatus = elevator. getStatus();    int capacity = elevator. getCapacity();    elevatorCapacityLabels[i]. Text = $ Capacity: {capacity} ;    // 更新状态标签颜色及文字    UpdateElevatorStatusLabels(currentStatus, i);  }}); } ```"
    }, {
    "id": 19,
    "url": "http://localhost:4000/Elevator-en/",
    "title": "Elevator Scheduling - Tongji University Operating System Course Project",
    "body": "2025/12/14 - Development Environment:  Development Environment: Windows 11 Development Software: Visual Studio 2022 Development Language: C# Main Referenced Modules: System, System. ThreadingImplemented Features:  Interconnected Up and Down Buttons: When the up or down buttons at the elevator entrance are pressed, all five elevators receive this request. The scheduling algorithm determines which specific elevator will respond to the request.  Independent Floor Buttons: Each elevator has its own floor buttons. When a floor button inside an elevator is pressed, that specific elevator responds to the request, with the timing determined by the scheduling algorithm.  Passenger Addition Function: Supports adding passengers by specifying their starting floor and destination floor. The scheduling algorithm decides which elevator will serve the passenger’s request.  Digital Display of Current Floor: Each elevator has a digital display showing its current floor.  Elevator Status Display: Each elevator has a label displaying its current status: up, down, wait, or alarm.  Elevator Capacity Display: Each elevator has a label showing its available capacity, initially set at 5.  Door Open and Close Buttons: When an elevator reaches a passenger’s floor or destination floor, it needs to complete door opening and closing operations.  Message Box: Displays prompt messages at specific times, showing which elevator has been assigned to a passenger and reminding users to open or close doors.  Passenger Status Table: Updates passenger locations in real-time based on their status, displaying only passengers who have not yet reached their destination floor. User Interface: User Guide:  Users can freely click number buttons and up/down buttons to let elevators run “empty” without passengers, which helps observe the actual performance of the elevator scheduling algorithm.  Users can also add passengers in the passenger management module on the right side, set their starting and destination floors, and observe which elevator the passenger is assigned to, as well as the actual floor changes when the passenger boards the elevator. When passengers reach their destination floor, they are removed from the table.  The status bar at the bottom displays prompt messages, reminding users to open and close doors when necessary.  Passengers can click the “Open” and “Close” buttons to open and close elevator doors, or press the “Alarm” button to put the elevator in alarm status.  The elevator’s current floor and remaining capacity are displayed above each elevator, while the current status is shown below each elevator. Main Design Approach: Implemented Classes:  Form1 Class: The main window of the program, responsible for UI display and updates, handling UI click events, managing passenger-related logic, and subscribing to events defined in ElevatorController.  ElevatorController Class: Implements the elevator scheduling algorithm, manages the elevator list, and defines key events.  Elevator Class: Records elevator properties, including current floor, target floor, status, and capacity. Provides common methods to set and retrieve these properties.  Passenger Class: Records each passenger’s ID, current floor, destination floor, assigned elevator, and whether the request has been processed. Elevator Class: The elevator entity records each elevator’s status (wait, up, down, alarm), current floor, and target floor. It defines necessary methods to get or set member variables within the elevator: namespace ElevatorSystem{  public enum status  {    wait, up, down, alarm  };  public class Elevator  {    status currentStatus;    int currentFloor;    int targetFloor;    int capacity;    public Elevator(int current=0,int target=0)    {       currentFloor = current;      targetFloor = target;      capacity = 5;      currentStatus = status. wait;    }    public int getCurrentFloor() { return currentFloor; }    public int getTargetFloor() { return targetFloor;}    public int getCapacity() { return capacity;}    public void takePassenger() { capacity--; }    public void ariveTargetFloor() { capacity++; }    public void setTargetFloor(int target) { targetFloor = target; }    public void setStatus(status sta) { currentStatus = sta; }    public status getStatus() { return currentStatus; }    public void up()    {       currentStatus = status. up;      if (currentFloor &lt; 20)      {        currentFloor++;        Thread. Sleep(500);      }    }    public void down()    {      currentStatus = status. down;      if (currentFloor &gt; 0)      {        currentFloor--;        Thread. Sleep(500);      }    }    public void move()    {      if (currentFloor &lt; targetFloor) up();      if (currentFloor &gt; targetFloor) down();    }    public bool check()    {      if (capacity &lt; 0)      {        currentStatus = status. alarm;        return false;      }      return true;    }  }}Passenger Class: The passenger entity records each passenger’s ID, current floor, destination floor, assigned elevator, and whether the request has been handled: namespace ElevatorSystem{  public class Passenger  {    public int id { get; set; }    public int currentFloor { get; set; }    public int targetFloor { get; set; }    public int assignedElevator { get; set; } // Stores the elevator number after assignment    public bool isHandled { get; set; } = false; // Default is false, indicating unprocessed    public Passenger(int ID, int current, int target, int assigned)    {      id = ID;      currentFloor = current;      targetFloor = target;      assignedElevator = assigned;    }  }}Relationships Between Classes: The interaction between the two classes is achieved by introducing an instance of ElevatorController named “manage” in Form1. Event subscriptions defined in ElevatorController are completed in Form1’s initialization function: public Form1(){  InitializeComponent();  InitializeElevatorUI();  InitialMassageBox();  InitializeFloorRequestButtons();  InitializePassengerManagementUI();  manage = new ElevatorController();    // Event subscriptions  manage. ElevatorMoved += Manage_ElevatorMoved;  manage. ElevatorRequestProcessed += Manage_ElevatorRequestProcessed;  manage. ElevatorExternalRequestProcessed += Manage_ExternalRequestProcessed;  manage. OpenDoorPressed += Manage_OpenDoorPressed;  manage. CloseDoorPressed += Manage_CloseDoorPressed;   LoadImages();  InitializeTimer();} In Form1, a list of Passenger type called passengers is defined to manage passengers.  In ElevatorController, an array of Elevator type called elevators is defined to manage the five elevators. Scheduling Algorithm:  Four two-dimensional arrays are defined in ElevatorController to record up and down requests that need processing, as well as up and down requests waiting to be processed:public int[,] upRequest = new int[ElevatorsCount, FloorsCount];public int[,] downRequest = new int[ElevatorsCount, FloorsCount];// The wait arrays store requests that require the elevator to change status before processingpublic int[,] waitUpRequest = new int[ElevatorsCount,FloorsCount];public int[,] waitDownRequest = new int[ElevatorsCount, FloorsCount];   The wait arrays store requests that require the elevator to undergo a status change before processing.     When the up button is pressed, public int handleUpRequest(int floor) is called to process the up request. When the down button is pressed, public int handleDownRequest(int floor) is called to process the down request. Both functions return the assigned elevator number. Specifically, the scheduling algorithm works as follows (using up request processing as an example):     Calculate the distance between each elevator and the floor where the up button was pressed based on each elevator’s status and location:          If the elevator is stationary, this distance equals the absolute value of the elevator’s floor minus the up button’s floor.           If the elevator is moving upward, there are two cases:          If the elevator’s current floor is higher than the up button’s floor, the distance equals the absolute value of the highest floor in the elevator’s current upward requests minus the elevator’s floor, plus the absolute value of the highest floor in the elevator’s current upward requests minus the up button’s floor.      If the elevator’s current floor is lower than the up button’s floor, the distance equals the absolute value of the elevator’s current floor minus the up button’s floor.               If the elevator is moving downward, the distance equals the absolute value of the lowest floor in the elevator’s current downward requests minus the elevator’s floor, plus the absolute value of the lowest floor in the elevator’s current downward requests minus the up button’s floor.          Select the elevator closest to the floor where the up button was pressed and add the floor to its upward request list:      If the elevator is currently stationary, there are two cases:         If the up button’s floor is higher than the elevator’s floor, add the request to upRequest[elevatorIndex,floor], as the elevator will soon change to upward status and can process the request immediately.      If the up button’s floor is lower than the elevator’s floor, add the request to waitUpRequest[elevatorIndex,floor], as the elevator needs to first change to downward status, then to upward status, before processing the request.           If the elevator is currently moving upward, there are two cases:         If the up button’s floor is higher than the elevator’s floor, add the request to upRequest[elevatorIndex,floor], as the elevator can respond to the request without changing status.      If the up button’s floor is lower than the elevator’s floor, add the request to waitUpRequest[elevatorIndex,floor], as the elevator needs to change status to respond to the request.           If the elevator is moving downward, add the request directly to waitUpRequest[elevator,Index], as the elevator needs to change status to respond to the request.    public int handleUpRequest(int floor){  int minDist = FloorsCount + 1;  int elevatorIndex = ElevatorsCount;  for(int i=0;i&lt;ElevatorsCount;i++)  {    int currentFloor = elevators[i]. getCurrentFloor();    if (elevators[i]. getStatus()==status. alarm)    {      continue;    }    if (elevators[i]. getStatus()==status. wait)    {      if(Math. Abs(currentFloor-floor) &lt; minDist)      {        minDist=Math. Abs(currentFloor-floor);        elevatorIndex=i;      }    }    else if (elevators[i]. getStatus()==status. up)    {      if(currentFloor &lt;= floor)      {        if(Math. Abs(currentFloor-floor)&lt;minDist)        {           minDist = Math. Abs(currentFloor-floor);          elevatorIndex = i;         }      }      else if(currentFloor &gt; floor)      {        int tmp = 0;        // Find the highest floor in current upward requests        for(int j=FloorsCount-1;j&gt;=0;j--)        {          if (upRequest[i, j] == 1)          {            tmp = j;            break;          }        }        // Calculate distance        int dist = Math. Abs(tmp - currentFloor) + Math. Abs(tmp - floor);        if(dist&lt;minDist)        {          minDist=dist;          elevatorIndex = i;        }      }    }    else if (elevators[i]. getStatus()==status. down)    {      int tmp = 0;      // Find the lowest floor in current downward requests      for(int j=0;j&lt;FloorsCount;j++)      {        if (downRequest[i, j] == 1)        {          tmp = j;          break;        }      }      int dist=Math. Abs(tmp - currentFloor) + Math. Abs(tmp - floor);      if(dist&lt;minDist)       {        minDist=dist;        elevatorIndex = i;      }    }  }  int currenFloor = elevators[elevatorIndex]. getCurrentFloor();  if (elevators[elevatorIndex]. getStatus()==status. wait)   {        if(floor &gt;= currenFloor)      upRequest[elevatorIndex, floor] = 1;    else      waitUpRequest[elevatorIndex, floor] = 1;        //upRequest[elevatorIndex, floor] = 1;  }  else if (elevators[elevatorIndex]. getStatus()==status. up)      {    if (floor &gt;= currenFloor)      upRequest[elevatorIndex, floor] = 1;    else      waitUpRequest[elevatorIndex, floor] = 1;  }  else    waitUpRequest[elevatorIndex,floor] = 1;  return elevatorIndex;} When a floor button is pressed, upRequest and downRequest are directly modified. When a floor lower than the elevator’s current floor is pressed in an upward-moving elevator, it will not be responded to. Similarly, when a floor higher than the current floor is pressed in a downward-moving elevator, it will not be responded to:private void FloorButton_Click(object sender, EventArgs e, int elevatorIndex, int floor){  Button clickButton = sender as Button;    // Handle floor button click event  //MessageBox. Show($ Floor {floor + 1} button of Elevator {elevatorIndex + 1} was clicked );  if (manage. elevators[elevatorIndex]. getStatus()==status. up)  {    if (floor &gt;= manage. elevators[elevatorIndex]. getCurrentFloor())     {      manage. upRequest[elevatorIndex, floor] = 1;      if (clickButton != null)      {        clickButton. BackColor = Color. Green;      }    }  }  else if (manage. elevators[elevatorIndex]. getStatus()==status. down)   {    if (floor &lt;= manage. elevators[elevatorIndex]. getCurrentFloor())    {      manage. downRequest[elevatorIndex, floor] = 1;      if (clickButton != null)      {        clickButton. BackColor = Color. Green;      }    }  }  else  {    if (floor &gt;= manage. elevators[elevatorIndex]. getCurrentFloor())    {      manage. upRequest[elevatorIndex, floor] = 1;      if (clickButton != null)      {        clickButton. BackColor = Color. Green;      }    }    else     {      manage. downRequest[elevatorIndex,floor] = 1;      if (clickButton != null)      {        clickButton. BackColor = Color. Green;      }    }  }}Elevator Operation Logic:  A separate thread is started for each elevator, with threads set as background threads. Each thread executes the private void ElevatorRoutine(int elevatorIndex) method:private void StartElevatorThreads(){  for(int i=0;i&lt;ElevatorsCount;i++)  {    int index = i;    Thread elevatorThread = new Thread(() =&gt; ElevatorRoutine(index))    {      IsBackground = true    };    elevatorThread. Start();  }} private void ElevatorRoutine(int elevatorIndex) {  while (true)  {     Thread. Sleep(500);    pullUpward(elevatorIndex);    Thread. Sleep(500);    prepareForDown(elevatorIndex);    Thread. Sleep(500);    pushDownward(elevatorIndex);    Thread. Sleep(500);    prepareForUp(elevatorIndex);  }} Upward requests are processed in void pullUpward(int elevatorIndex), and downward requests are processed in void pushDownward(int elevatorIndex).  Processing of waitUpRequest and waitDownRequest occurs in prepareForUp and prepareForDown respectively.  Threads are started in the ElevatorController’s initialization function:public ElevatorController(){  for(int i=0;i&lt;elevators. Length; i++)   {    elevators[i] = new Elevator();  }  for(int i=0;i &lt; ElevatorsCount;i++)  {    for(int j=0;j &lt; FloorsCount;j++)    {      upRequest[i, j] = 0;      downRequest[i, j] = 0;      waitUpRequest[i, j] = 0;      waitDownRequest[i, j] = 0;    }  }  StartElevatorThreads();}Event Definitions:  Five events are defined in ElevatorController:public event Action&lt;int, int&gt; ElevatorMoved;public event Action&lt;int, int&gt; ElevatorRequestProcessed;public event Action&lt;int, int&gt; ElevatorExternalRequestProcessed;public event Action&lt;int&gt; OpenDoorPressed;public event Action&lt;int&gt; CloseDoorPressed;These are used to handle elevator movement, processing of elevator floor requests and external requests, and door open/close button presses.  These events are subscribed to in Form1:manage. ElevatorMoved += Manage_ElevatorMoved;manage. ElevatorRequestProcessed += Manage_ElevatorRequestProcessed;manage. ElevatorExternalRequestProcessed += Manage_ExternalRequestProcessed;manage. OpenDoorPressed += Manage_OpenDoorPressed;manage. CloseDoorPressed += Manage_CloseDoorPressed;   Event subscription is a common pattern in software design, belonging to the broader publish-subscribe (pub-sub) pattern. In this pattern, components can announce (publish) the occurrence of certain events, while other components can express interest in these events (subscribe). When events occur, these subscribing components automatically receive notifications and respond accordingly.     For example, in the pullUpward method of ElevatorController, when executing the following code segment, the program checks whether there is a request at the elevator’s current floor. If there is, the request is responded to and the event is triggered. Then, methods that subscribed to the event will be called, the highlighting of floor buttons and up buttons will disappear, and the elevator’s position will be updated:  while (elevators[elevatorIndex]. getCurrentFloor() != elevators[elevatorIndex]. getTargetFloor()){  elevators[elevatorIndex]. move();  if (upRequest[elevatorIndex, elevators[elevatorIndex]. getCurrentFloor()] == 1)  {    upRequest[elevatorIndex, elevators[elevatorIndex]. getCurrentFloor()] = 0;    ElevatorRequestProcessed. Invoke(elevatorIndex, elevators[elevatorIndex]. getCurrentFloor());    ElevatorExternalRequestProcessed. Invoke(elevators[elevatorIndex]. getCurrentFloor(), 1);  }  ElevatorMoved. Invoke(elevatorIndex, elevators[elevatorIndex]. getCurrentFloor());}if (elevators[elevatorIndex]. getCurrentFloor() == i){  upRequest[elevatorIndex, i] = 0;  ElevatorRequestProcessed. Invoke(elevatorIndex, i);  ElevatorExternalRequestProcessed. Invoke(i, 1);}Timer Definitions:    Timers in programming are used to repeatedly execute certain tasks at set intervals or to execute tasks after a certain delay. The code checkElevatorTimer. Elapsed += CheckElevatorStatus; binds the CheckElevatorStatus method to the timer’s Elapsed event. This means that whenever the timer’s cycle ends, the CheckElevatorStatus method will be automatically called. AutoReset = true sets the timer to automatically restart after triggering the Elapsed event, making it a repeating periodic timer.     Three timers are used in the project: one for playing animations, one for checking elevator status, and one for updating the passenger list:  private void InitializeTimer(){  animationTimer. Interval = 200; // Set animation frame switching interval to 200 milliseconds  animationTimer. Tick += new EventHandler(AnimationTimer_Tick);  updateTimer = new System. Windows. Forms. Timer();  updateTimer. Interval = 1000; // Set update interval to 1000 milliseconds (1 second)  updateTimer. Tick += new EventHandler(UpdateTimer_Tick);  updateTimer. Start();  // Initialize timer  checkElevatorTimer = new System. Timers. Timer(1000); // Set time interval to 1 second  checkElevatorTimer. Elapsed += CheckElevatorStatus;  checkElevatorTimer. AutoReset = true;  checkElevatorTimer. Enabled = true; // Initial state is disabled} CheckElevatorStatus periodically checks whether any elevator has reached a passenger’s destination floor and updates the elevator’s status label:private async void CheckElevatorStatus(Object source, System. Timers. ElapsedEventArgs e){  // Execute operations that need to be completed on the UI thread within Task. Run  await Task. Run(() =&gt;  {    Invoke((MethodInvoker)delegate    {      foreach (var passenger in passengers)      {        if (!passenger. isHandled &amp;&amp; manage. elevators[passenger. assignedElevator]. getCurrentFloor() == passenger. currentFloor)        {          passenger. isHandled = true;          messageBox. AppendText($ Please press the open door button for Elevator {passenger. assignedElevator + 1} to let the passenger in. {Environment. NewLine} );          var openTcs = new TaskCompletionSource&lt;bool&gt;();          openDoorTcs[passenger. assignedElevator] = openTcs;          openTcs. Task. ContinueWith(async t =&gt;          {            // Wait two seconds, then execute subsequent logic            await Task. Delay(2000);            openDoorButtons[passenger. assignedElevator]. BackColor = Color. White;            var closeTcs = new TaskCompletionSource&lt;bool&gt;();            closeDoorTcs[passenger. assignedElevator] = closeTcs;            await closeTcs. Task;            // Delay two seconds after closing door            await Task. Delay(2000);            closeDoorButtons[passenger. assignedElevator]. BackColor = Color. White;            Invoke((MethodInvoker)(() =&gt; toTargetFloorOfPassenger(passenger. id, passenger. assignedElevator, passenger. targetFloor)));          }, TaskScheduler. FromCurrentSynchronizationContext());        }      }    });  });  // Other status updates must also be executed on the UI thread  Invoke((MethodInvoker)delegate  {    for (int i = 0; i &lt; ElevatorsCount; i++)    {      Elevator elevator = manage. elevators[i];      status currentStatus = elevator. getStatus();      int capacity = elevator. getCapacity();      elevatorCapacityLabels[i]. Text = $ Capacity: {capacity} ;      // Update status label colors and text      UpdateElevatorStatusLabels(currentStatus, i);    }  });}"
    }, {
    "id": 20,
    "url": "http://localhost:4000/LeetCode1219/",
    "title": "力扣第1219题黄金矿工时间复杂度新解",
    "body": "2025/12/11 - 算法思路: 用二维向量存储金矿的分布情况。算法首先遍历整个金矿，对于不为0的坐标将其设为起点，用DFS回溯搜索整张图，搜索过程中将已走过的坐标标记（金子数置0），同时记录当前收集到的金子数量。 类中有一个 max 变量记录最多收集到的金子数量，一个 path 变量记录最优情况的路径。当找到收集金子更多的路径时，会同时更新 max 与 path。回溯时，记录当前路径的栈 pop 一次，并释放标记。由此，即可找出收集黄金最多的路径与金子数。 复杂度分析: 鉴于搜索的结果取决于对有金子区域的遍历，因此设有金子区域一共有 \(k\) 个。再设行数为 \(m\)，列数为 \(n\)。显然，\(k \le mn\)，因此后续涉及 \(\min\{mn, k\}\) 运算时可以直接化简为 \(k\)。 在算法中使用了两个栈存储路径，因此空间复杂度为 \(O(k+k)\)，即 \(O(k)\)。 将每次向前探索作为基本操作。每个有金子的地点都可以作为起点开始DFS遍历，因此一共有 \(k\) 次遍历。在每次遍历中，除第一个地点外，每个地点都有最多三个不同的方向继续前进遍历，因此探索操作至少有 $3k$ 次。可知时间复杂度最差为 \(O(3^k)\)。 但是自己输入一个 \(k=25\) 的地图数据发现执行效率相当高，并没有体现出以3为底指数函数的低效率，推断“每个起点的总探索操作上限 \(3^k\) 次”这个数据将上限抬得过高。 因为探索操作都产生在有金子的格子里，所以将其单独拿出分析，对于任何一条收集路线，除开首尾两格，中间的格子被路线穿过都不外乎如下七种情况：  左进上出或上进左出——简写为 LU 右进上出或上进右出——简写为 RU 还有 LD、RD、LR、UD 没有被路线穿过的情况，记为 N这样原先由每个格子三种探索方向构成的解空间树就变成了对每个格子其中穿过情况生成解空间树。 再将整张图中所有有金子的格子（除首尾）如下交错划分成黑白两种：（此处为方便说明假设它们恰好聚在这 \(3 \times 3\) 格子里） 从刚才的 7 种情况可以知道，如果我们确定每个黑色格子的情况，白色格子的情况就被确定了，所以我们只需要考虑黑色格子，显然这样的划分形成了 \(k/2\) 数量级的黑格子。 解空间树生成时，遍历 B 的 7 种情况前它周围四个角的黑格情况已经被确定了（除开首尾，这对时间复杂度分析没有影响），图中假设 A 被确定为 LR，那么 B 只剩 LU、RU、UD、N 四种情况。其它同理，因此实际上生成解空间树时每个黑格子下一步能够做出的探索选择只有 4 种，时间复杂度最差不超过 \(O(4^{k/2}) = O(2^k)\)。 实际情况下因为有金子的格子不会总是聚在一起，因此每个黑格子的选择大概率会少于 4 种，时间复杂度会更低。 综上，最差时间复杂度不超过 \(O(2^k)\)。 本题恰好是算法课作业遇到的，觉得网上的时间分析和体感不同，稍作改进。 "
    }, {
    "id": 21,
    "url": "http://localhost:4000/About-This-Website/",
    "title": "关于本站 - About This Website",
    "body": "2025/11/10 - Welcome to Hyrule Royal Warehouse. This is a personal blog website with no commercial intent. Here you can find blogs about computing, coding, applications and theories behind them. You can find all blogs bilingual with Chinese and English. They might not be side-by-side, but both cover same contents. All blogs are free to share and repost with citation. You can also buy me a coffee if you find the website useful. Really appreciate that. 欢迎来到海拉鲁皇家仓库。本站无商业用途，内容涵盖计算机、代码、应用及其背后的支持理论。所有文章都一式两份（中英）。转载文章需标明来源。在首页可以打赏。 "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});


    
function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




<form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small"  id="lunrsearch" name="q" value="" placeholder="Type keyword and enter..."> 
</form>
            </ul>
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        <div class="container">
    

    
    
    
<!-- Begin post excerpts, let's highlight the first 4 posts on top -->
<div class="row remove-site-content-margin">
    
    <!-- latest post -->
    
    <div class="col-md-6">
    <div class="card border-0 mb-4 box-shadow">   
    <a href="/FileManage-en/">
    <div class="topfirstimage" style="background-image: url( /assets/images/filemanage/cover.jpg); height: 200px;    background-size: cover;    background-repeat: no-repeat;"></div>     
    </a>
    <div class="card-body px-0 pb-0 d-flex flex-column align-items-start">
    <h2 class="h4 font-weight-bold">
    <a class="text-dark" href="/FileManage-en/">File Management Simulation - TJU Operating Systems Course Project</a>
    </h2>
    <p class="excerpt">
        File Management Simulation System Design Report
    </p>
    <div>
        <small class="d-block text-muted">
            <span class="catlist">
                
                <a class="text-capitalize text-muted smoothscroll" href="/categories.html#algorithms">Algorithms</a><span class="sep">, </span>
                
                </span>                   
        </small>
        <small class="text-muted">
            Dec 27, 2025
        </small>
    </div>
    </div>
    </div>
    </div>
    
    <div class="col-md-6">
        
        <!-- second latest post --><div class="mb-3 d-flex align-items-center">                
                
                <div class="col-md-4">
                <a href="/FileManage/">
                 <img class="w-100" src="http://localhost:4000/assets/images/filemanage/cover.jpg" alt="文件管理模拟 - TJU操作系统课设方案">
                </a>
                </div>
                                
                <div>
                    <h2 class="mb-2 h6 font-weight-bold">
                    <a class="text-dark" href="/FileManage/">文件管理模拟 - TJU操作系统课设方案</a>
                    </h2>
                    <small class="d-block text-muted">
                        <span class="catlist">
                        
                        <a class="text-capitalize text-muted smoothscroll" href="/categories.html#算法">算法</a><span class="sep">, </span>
                        
                        </span>                   
                    </small>
                    <small class="text-muted">
                        Dec 26, 2025
                    </small>
                </div>
            </div>
        
        <!-- third latest post --><div class="mb-3 d-flex align-items-center">                
                
                <div class="col-md-4">
                <a href="/Cache-en/">
                 <img class="w-100" src="/assets/images/cache/cover.avif" alt="Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures">
                </a>
                </div>
                                
                <div>
                    <h2 class="mb-2 h6 font-weight-bold">
                    <a class="text-dark" href="/Cache-en/">Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures</a>
                    </h2>
                    <small class="d-block text-muted">
                        <span class="catlist">
                        
                        <a class="text-capitalize text-muted smoothscroll" href="/categories.html#theory">Theory</a><span class="sep">, </span>
                        
                        </span>                   
                    </small>
                    <small class="text-muted">
                        Dec 17, 2025
                    </small>
                </div>
            </div>
        
        <!-- fourth latest post --><div class="mb-3 d-flex align-items-center">                
                
                <div class="col-md-4">
                <a href="/Cache/">
                <img class="w-100" src="/assets/images/cache/cover.avif" alt="多核体系下Cache目录一致性协议优化方案">
                </a>
                </div>
                                
                <div>
                    <h2 class="mb-2 h6 font-weight-bold">
                    <a class="text-dark" href="/Cache/">多核体系下Cache目录一致性协议优化方案</a>
                    </h2>
                    <small class="d-block text-muted">
                        <span class="catlist">
                        
                        <a class="text-capitalize text-muted smoothscroll" href="/categories.html#理论">理论</a><span class="sep">, </span>
                        
                        </span>                   
                    </small>
                    <small class="text-muted">
                        Dec 16, 2025
                    </small>
                </div>
            </div>
        
    </div>
    
</div>
    
<!-- Sticky - add sticky tag to the post you want to highlight here - tags: [sticky] -->
 

 

 

 

 

 

 

 

 

<div class="jumbotron jumbotron-fluid jumbotron-home pt-0 pb-0 mt-3 mb-2rem bg-lightblue position-relative">
    <div class="pl-4 pr-0 h-100 tofront">
        <div class="row justify-content-between">
            <div class="col-md-6 pt-6 pb-6 pr-lg-4 align-self-center">
                <h1 class="mb-3">关于本站 - About This Website</h1>
                <p class="mb-3 lead">
                    Welcome to Hyrule Royal Warehouse.
                </p>
                <a href="/About-This-Website/" class="btn btn-dark">Read More</a>
            </div>
            <div class="col-md-6 d-none d-md-block pr-0" style="background-size:cover;background-image:url(/assets/images/About/cover.jpg);">	
            </div>
        </div>
    </div>
</div> 




    


 <!--endif page url is / -->
    


<!-- Now the rest of the posts with the usual loop but with an offset:4 on the first page so we can skeep the first 4 posts displayed above -->
    
<div class="row mt-3">
   
    <div class="col-md-8 main-loop">
        
        <h4 class="font-weight-bold spanborder"><span>All</span></h4>
        

        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/FileManage-en/">File Management Simulation - TJU Operating Systems Course Project</a>
	</h2>
	<p class="excerpt">
	   File Management Simulation System Design Report
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#algorithms">Algorithms</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 27, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/FileManage-en/">
	<img class="w-100" src="/assets/images/filemanage/cover.jpg" alt="File Management Simulation - TJU Operating Systems Course Project">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/FileManage/">文件管理模拟 - TJU操作系统课设方案</a>
	</h2>
	<p class="excerpt">
	   文件管理模拟系统 设计方案报告
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#算法">算法</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 26, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/FileManage/">
	<img class="w-100" src="/assets/images/filemanage/cover.jpg" alt="文件管理模拟 - TJU操作系统课设方案">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/Cache-en/">Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures</a>
	</h2>
	<p class="excerpt">
	   In multi-core system architectures, cache coherence protocols are primarily classified into snooping protocols and directory protocols, with the latter generally being considered supe...
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#theory">Theory</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 17, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/Cache-en/">
	<img class="w-100" src="/assets/images/cache/cover.avif" alt="Optimization Schemes for Cache Directory Coherence Protocols in Multi-Core Architectures">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/Cache/">多核体系下Cache目录一致性协议优化方案</a>
	</h2>
	<p class="excerpt">
	   在多核系统结构下，Cache一致性协议有监听协议和目录协议两种，其中后者是更优的。在经典的目录中，每一个数据块都有对应的目录项，这使得存储的空间开销很大。故而可以使用稀疏目录，通过只维护被Cache缓存的数据对应的信息来减少开销。稀疏目录中的Cuckoo目录是一种较好的方案，它使用哈希表的方式对稀疏目录进行改进。一种潜力更好的目录是Stash目录，它在目录中增加了...
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#理论">理论</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 16, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/Cache/">
	<img class="w-100" src="/assets/images/cache/cover.avif" alt="多核体系下Cache目录一致性协议优化方案">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/LeetCode1219-en/">A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold</a>
	</h2>
	<p class="excerpt">
	   Algorithm Approach
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#algorithm">Algorithm</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 15, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/LeetCode1219-en/">
	<img class="w-100" src="/assets/images/leetcode1219/cover.jpg" alt="A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/Elevator/">电梯调度 - TJU操作系统课设方案</a>
	</h2>
	<p class="excerpt">
	   开发环境
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#算法">算法</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 15, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/Elevator/">
	<img class="w-100" src="/assets/images/elevator/cover.jpg" alt="电梯调度 - TJU操作系统课设方案">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/Elevator-en/">Elevator Scheduling - Tongji University Operating System Course Project</a>
	</h2>
	<p class="excerpt">
	   Development Environment
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#algorithm">Algorithm</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 14, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/Elevator-en/">
	<img class="w-100" src="/assets/images/elevator/cover.jpg" alt="Elevator Scheduling - Tongji University Operating System Course Project">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/LeetCode1219/">力扣第1219题黄金矿工时间复杂度新解</a>
	</h2>
	<p class="excerpt">
	   算法思路
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#算法">算法</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Dec 11, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/LeetCode1219/">
	<img class="w-100" src="/assets/images/leetcode1219/cover.jpg" alt="力扣第1219题黄金矿工时间复杂度新解">
	</a>
	</div>

</div>
        
        
        
            <div class="mb-5 d-flex justify-content-between main-loop-card">
<div class="pr-3">
	<h2 class="mb-1 h4 font-weight-bold">
	<a class="text-dark" href="/About-This-Website/">关于本站 - About This Website</a>
	</h2>
	<p class="excerpt">
	   Welcome to Hyrule Royal Warehouse.
	</p>
	<small class="d-block text-muted">
		In <span class="catlist">
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#入门">入门</a><span class="sep">, </span>
		
		<a class="text-capitalize text-muted smoothscroll" href="/categories.html#start">Start</a><span class="sep">, </span>
		
		</span>
	</small>
	<small class="text-muted">
		Nov 10, 2025
	</small>
</div>

	<div class="col-md-3 pr-0 text-right">
	<a href="/About-This-Website/">
	<img class="w-100" src="/assets/images/About/cover.jpg" alt="关于本站 - About This Website">
	</a>
	</div>

</div>
        
        
        
        <div class="mt-5">
         <!-- Pagination links -->
                  
        </div>
        
    </div>
    
    <div class="col-md-4">
        <div class="sticky-top sticky-top-offset">
    <h4 class="font-weight-bold spanborder"><span>Featured</span></h4>  
    <ol class="list-featured">				
                        
            <li class="mb-4">
            <span>
                <h6 class="font-weight-bold">
                    <a href="/LeetCode1219-en/" class="text-dark">A New Perspective on Time Complexity for LeetCode 1219: Path with Maximum Gold</a>
                </h6>
                <span class="d-block text-muted">
                    In <span class="catlist">
                    
                    <a class="text-capitalize text-muted smoothscroll" href="/categories.html#algorithm">Algorithm</a><span class="sep">, </span>
                    
                    </span>
                </span>
            </span>
            </li>                
           
    </ol>
</div>     
    </div>
    
</div>



</div>
    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

    <script src="/assets/js/theme.js"></script>


    <!-- Footer -->
    <!-- <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                <span class="navbar-brand mr-2 mb-0"><strong>Mundana</strong></span>
                <span>Copyright © <script>document.write(new Date().getFullYear())</script>.</span> -->

                <!--  Github Repo Star Btn-->
                <!-- <a class="text-dark ml-1" target="_blank" href="https://github.com/wowthemesnet/mundana-theme-jekyll"><i class="fab fa-github"></i> Fork on Github</a>

            </div>
            <div>
                Made with <a target="_blank" class="text-dark font-weight-bold" href="https://www.wowthemes.net/mundana-jekyll-theme/"> Mundana Jekyll Theme </a> by <a class="text-dark" target="_blank" href="https://www.wowthemes.net">WowThemes</a>.
            </div>
        </div>
        </div>
    </footer> -->

    <!-- All this area goes before </body> closing tag --> 


    <footer class="footer">
  <data class="u-url" href="/"></data>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="text-muted">
          © 2025 Hyrule Royal Academy
        </p>
        
        <!-- 不蒜子访问统计 -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <p class="text-muted small">
          <span id="busuanzi_container_site_pv">
            本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
          </span>
        </p>
      </div>
    </div>
  </div>
</footer>
    <script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/6e7b1df4488fe37755abc2142/f7e5cc6bdd0f8f00bccf97724.js");</script>
</body>

</html>
